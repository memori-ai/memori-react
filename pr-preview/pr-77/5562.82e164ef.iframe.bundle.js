(self.webpackChunk_memori_ai_memori_react=self.webpackChunk_memori_ai_memori_react||[]).push([[5562],{"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js":module=>{module.exports=function _arrayLikeToArray(r,a){(null==a||a>r.length)&&(a=r.length);for(var e=0,n=Array(a);e<a;e++)n[e]=r[e];return n},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/arrayWithHoles.js":module=>{module.exports=function _arrayWithHoles(r){if(Array.isArray(r))return r},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/classCallCheck.js":module=>{module.exports=function _classCallCheck(a,n){if(!(a instanceof n))throw new TypeError("Cannot call a class as a function")},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/createClass.js":(module,__unused_webpack_exports,__webpack_require__)=>{var toPropertyKey=__webpack_require__("./node_modules/@babel/runtime/helpers/toPropertyKey.js");function _defineProperties(e,r){for(var t=0;t<r.length;t++){var o=r[t];o.enumerable=o.enumerable||!1,o.configurable=!0,"value"in o&&(o.writable=!0),Object.defineProperty(e,toPropertyKey(o.key),o)}}module.exports=function _createClass(e,r,t){return r&&_defineProperties(e.prototype,r),t&&_defineProperties(e,t),Object.defineProperty(e,"prototype",{writable:!1}),e},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js":module=>{module.exports=function _iterableToArrayLimit(r,l){var t=null==r?null:"undefined"!=typeof Symbol&&r[Symbol.iterator]||r["@@iterator"];if(null!=t){var e,n,i,u,a=[],f=!0,o=!1;try{if(i=(t=t.call(r)).next,0===l){if(Object(t)!==t)return;f=!1}else for(;!(f=(e=i.call(t)).done)&&(a.push(e.value),a.length!==l);f=!0);}catch(r){o=!0,n=r}finally{try{if(!f&&null!=t.return&&(u=t.return(),Object(u)!==u))return}finally{if(o)throw n}}return a}},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/nonIterableRest.js":module=>{module.exports=function _nonIterableRest(){throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.")},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/slicedToArray.js":(module,__unused_webpack_exports,__webpack_require__)=>{var arrayWithHoles=__webpack_require__("./node_modules/@babel/runtime/helpers/arrayWithHoles.js"),iterableToArrayLimit=__webpack_require__("./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js"),unsupportedIterableToArray=__webpack_require__("./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"),nonIterableRest=__webpack_require__("./node_modules/@babel/runtime/helpers/nonIterableRest.js");module.exports=function _slicedToArray(r,e){return arrayWithHoles(r)||iterableToArrayLimit(r,e)||unsupportedIterableToArray(r,e)||nonIterableRest()},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/toPrimitive.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js").default;module.exports=function toPrimitive(t,r){if("object"!=_typeof(t)||!t)return t;var e=t[Symbol.toPrimitive];if(void 0!==e){var i=e.call(t,r||"default");if("object"!=_typeof(i))return i;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===r?String:Number)(t)},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/toPropertyKey.js":(module,__unused_webpack_exports,__webpack_require__)=>{var _typeof=__webpack_require__("./node_modules/@babel/runtime/helpers/typeof.js").default,toPrimitive=__webpack_require__("./node_modules/@babel/runtime/helpers/toPrimitive.js");module.exports=function toPropertyKey(t){var i=toPrimitive(t,"string");return"symbol"==_typeof(i)?i:i+""},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/typeof.js":module=>{function _typeof(o){return module.exports=_typeof="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o},module.exports.__esModule=!0,module.exports.default=module.exports,_typeof(o)}module.exports=_typeof,module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":(module,__unused_webpack_exports,__webpack_require__)=>{var arrayLikeToArray=__webpack_require__("./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");module.exports=function _unsupportedIterableToArray(r,a){if(r){if("string"==typeof r)return arrayLikeToArray(r,a);var t={}.toString.call(r).slice(8,-1);return"Object"===t&&r.constructor&&(t=r.constructor.name),"Map"===t||"Set"===t?Array.from(r):"Arguments"===t||/^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)?arrayLikeToArray(r,a):void 0}},module.exports.__esModule=!0,module.exports.default=module.exports},"./node_modules/@headlessui/react/dist/components/radio-group/radio-group.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{z:()=>et});var react=__webpack_require__("./node_modules/react/index.js"),render=__webpack_require__("./node_modules/@headlessui/react/dist/utils/render.js"),use_id=__webpack_require__("./node_modules/@headlessui/react/dist/hooks/use-id.js"),match=__webpack_require__("./node_modules/@headlessui/react/dist/utils/match.js"),use_iso_morphic_effect=__webpack_require__("./node_modules/@headlessui/react/dist/hooks/use-iso-morphic-effect.js"),keyboard=__webpack_require__("./node_modules/@headlessui/react/dist/components/keyboard.js"),focus_management=__webpack_require__("./node_modules/@headlessui/react/dist/utils/focus-management.js");var use_sync_refs=__webpack_require__("./node_modules/@headlessui/react/dist/hooks/use-sync-refs.js"),use_event=__webpack_require__("./node_modules/@headlessui/react/dist/hooks/use-event.js");let u=(0,react.createContext)(null);function c(){let o=(0,react.useContext)(u);if(null===o){let t=new Error("You used a <Label /> component, but it is not inside a relevant parent.");throw Error.captureStackTrace&&Error.captureStackTrace(t,c),t}return o}function label_M(){let[o,t]=(0,react.useState)([]);return[o.length>0?o.join(" "):void 0,(0,react.useMemo)(()=>function(e){let l=(0,use_event._)(a=>(t(i=>[...i,a]),()=>t(i=>{let n=i.slice(),d=n.indexOf(a);return-1!==d&&n.splice(d,1),n}))),r=(0,react.useMemo)(()=>({register:l,slot:e.slot,name:e.name,props:e.props}),[l,e.slot,e.name,e.props]);return react.createElement(u.Provider,{value:r},e.children)},[t])]}let F=(0,render.FX)(function(t,s){let{passive:e=!1,...l}=t,r=c(),a=`headlessui-label-${(0,use_id.B)()}`,i=(0,use_sync_refs.P)(s);(0,use_iso_morphic_effect.s)(()=>r.register(a),[a,r.register]);let n={ref:i,...r.props,id:a};return e&&("onClick"in n&&delete n.onClick,"onClick"in l&&delete l.onClick),(0,render.XX)({ourProps:n,theirProps:l,slot:r.slot||{},defaultTag:"label",name:r.name||"Label"})});var t,description=__webpack_require__("./node_modules/@headlessui/react/dist/components/description/description.js"),use_tree_walker=__webpack_require__("./node_modules/@headlessui/react/dist/hooks/use-tree-walker.js"),internal_hidden=__webpack_require__("./node_modules/@headlessui/react/dist/internal/hidden.js"),utils_form=__webpack_require__("./node_modules/@headlessui/react/dist/utils/form.js"),owner=__webpack_require__("./node_modules/@headlessui/react/dist/utils/owner.js"),use_controllable=__webpack_require__("./node_modules/@headlessui/react/dist/hooks/use-controllable.js"),bugs=__webpack_require__("./node_modules/@headlessui/react/dist/utils/bugs.js"),ye=((t=ye||{})[t.RegisterOption=0]="RegisterOption",t[t.UnregisterOption=1]="UnregisterOption",t);let ge={0(a,n){let t=[...a.options,{id:n.id,element:n.element,propsRef:n.propsRef}];return{...a,options:(0,focus_management.wl)(t,l=>l.element.current)}},1(a,n){let t=a.options.slice(),l=a.options.findIndex(O=>O.id===n.id);return-1===l?a:(t.splice(l,1),{...a,options:t})}},V=(0,react.createContext)(null);function te(a){let n=(0,react.useContext)(V);if(null===n){let t=new Error(`<${a} /> is missing a parent <RadioGroup /> component.`);throw Error.captureStackTrace&&Error.captureStackTrace(t,te),t}return n}function ve(a,n){return(0,match.Y)(n.type,ge,a,n)}V.displayName="RadioGroupContext";let Ee=(0,render.FX)(function(n,t){let{value:l,defaultValue:O,name:c,onChange:M,by:E=(e,r)=>e===r,disabled:P=!1,...S}=n,u=(0,use_event._)("string"==typeof E?(e,r)=>{let o=E;return(null==e?void 0:e[o])===(null==r?void 0:r[o])}:E),[_,A]=(0,react.useReducer)(ve,{options:[]}),i=_.options,[R,U]=label_M(),[f,D]=(0,description.r)(),H=`headlessui-radiogroup-${(0,use_id.B)()}`,h=(0,react.useRef)(null),G=(0,use_sync_refs.P)(h,t),[p,k]=(0,use_controllable.P)(l,M,O),F=(0,react.useMemo)(()=>i.find(e=>!e.propsRef.current.disabled),[i]),L=(0,react.useMemo)(()=>i.some(e=>u(e.propsRef.current.value,p)),[i,p]),T=(0,use_event._)(e=>{var o;if(P||u(e,p))return!1;let r=null==(o=i.find(w=>u(w.propsRef.current.value,e)))?void 0:o.propsRef.current;return(null==r||!r.disabled)&&(null==k||k(e),!0)});(0,use_tree_walker.i)({container:h.current,accept:e=>"radio"===e.getAttribute("role")?NodeFilter.FILTER_REJECT:e.hasAttribute("role")?NodeFilter.FILTER_SKIP:NodeFilter.FILTER_ACCEPT,walk(e){e.setAttribute("role","none")}});let N=(0,use_event._)(e=>{let r=h.current;if(!r)return;let o=(0,owner.T)(r),w=i.filter(d=>!1===d.propsRef.current.disabled).map(d=>d.element.current);switch(e.key){case keyboard.D.Enter:(0,utils_form.q)(e.currentTarget);break;case keyboard.D.ArrowLeft:case keyboard.D.ArrowUp:if(e.preventDefault(),e.stopPropagation(),(0,focus_management.CU)(w,focus_management.BD.Previous|focus_management.BD.WrapAround)===focus_management.Me.Success){let m=i.find(K=>K.element.current===(null==o?void 0:o.activeElement));m&&T(m.propsRef.current.value)}break;case keyboard.D.ArrowRight:case keyboard.D.ArrowDown:if(e.preventDefault(),e.stopPropagation(),(0,focus_management.CU)(w,focus_management.BD.Next|focus_management.BD.WrapAround)===focus_management.Me.Success){let m=i.find(K=>K.element.current===(null==o?void 0:o.activeElement));m&&T(m.propsRef.current.value)}break;case keyboard.D.Space:{e.preventDefault(),e.stopPropagation();let d=i.find(m=>m.element.current===(null==o?void 0:o.activeElement));d&&T(d.propsRef.current.value)}}}),x=(0,use_event._)(e=>(A({type:0,...e}),()=>A({type:1,id:e.id}))),s=(0,react.useMemo)(()=>({registerOption:x,firstOption:F,containsCheckedOption:L,change:T,disabled:P,value:p,compare:u}),[x,F,L,T,P,p,u]),y={ref:G,id:H,role:"radiogroup","aria-labelledby":R,"aria-describedby":f,onKeyDown:N},W=(0,react.useMemo)(()=>({value:p}),[p]);return react.createElement(D,{name:"RadioGroup.Description"},react.createElement(U,{name:"RadioGroup.Label"},react.createElement(V.Provider,{value:s},null!=c&&null!=p&&(0,utils_form.h)({[c]:p}).map(([e,r])=>react.createElement(internal_hidden.j,{features:internal_hidden.O.Hidden,...(0,render.oE)({key:e,as:"input",type:"radio",checked:null!=r,hidden:!0,readOnly:!0,name:e,value:r})})),(0,render.XX)({ourProps:y,theirProps:S,slot:W,defaultTag:"div",name:"RadioGroup"}))))});var Pe=(t=>(t[t.Empty=1]="Empty",t[t.Active=2]="Active",t))(Pe||{});let he=(0,render.FX)(function(n,t){let l=(0,react.useRef)(null),O=(0,use_sync_refs.P)(l,t),c=`headlessui-radiogroup-option-${(0,use_id.B)()}`,[M,E]=label_M(),[P,S]=(0,description.r)(),{addFlag:u,removeFlag:_,hasFlag:A}=function b(g=0){let[r,l]=(0,react.useState)(g);return{addFlag:(0,react.useCallback)(e=>l(a=>a|e),[r]),hasFlag:(0,react.useCallback)(e=>Boolean(r&e),[r]),removeFlag:(0,react.useCallback)(e=>l(a=>a&~e),[l]),toggleFlag:(0,react.useCallback)(e=>l(a=>a^e),[l])}}(1),{value:i,disabled:R=!1,...U}=n,f=(0,react.useRef)({value:i,disabled:R});(0,use_iso_morphic_effect.s)(()=>{f.current.value=i},[i,f]),(0,use_iso_morphic_effect.s)(()=>{f.current.disabled=R},[R,f]);let{registerOption:D,disabled:H,change:h,firstOption:G,containsCheckedOption:p,value:k,compare:F}=te("RadioGroup.Option");(0,use_iso_morphic_effect.s)(()=>D({id:c,element:l,propsRef:f}),[c,D,l,n]);let L=(0,use_event._)(r=>{var o;if((0,bugs.l)(r.currentTarget))return r.preventDefault();!h(i)||(u(2),null==(o=l.current)||o.focus())}),T=(0,use_event._)(r=>{if((0,bugs.l)(r.currentTarget))return r.preventDefault();u(2)}),N=(0,use_event._)(()=>_(2)),x=(null==G?void 0:G.id)===c,s=H||R,y=F(k,i),W={ref:O,id:c,role:"radio","aria-checked":y?"true":"false","aria-labelledby":M,"aria-describedby":P,"aria-disabled":!!s||void 0,tabIndex:s?-1:y||!p&&x?0:-1,onClick:s?void 0:L,onFocus:s?void 0:T,onBlur:s?void 0:N},e=(0,react.useMemo)(()=>({checked:y,disabled:s,active:A(2)}),[y,s,A]);return react.createElement(S,{name:"RadioGroup.Description"},react.createElement(E,{name:"RadioGroup.Label"},(0,render.XX)({ourProps:W,theirProps:U,slot:e,defaultTag:"div",name:"RadioGroup.Option"})))}),et=Object.assign(Ee,{Option:he,Label:F,Description:description.V})},"./node_modules/automation-events/build/es5/bundle.js":function(__unused_webpack_module,exports,__webpack_require__){!function(exports,_slicedToArray,_classCallCheck,_createClass){"use strict";function _interopDefaultLegacy(e){return e&&"object"==typeof e&&"default"in e?e:{default:e}}var _slicedToArray__default=_interopDefaultLegacy(_slicedToArray),_classCallCheck__default=_interopDefaultLegacy(_classCallCheck),_createClass__default=_interopDefaultLegacy(_createClass),createExtendedExponentialRampToValueAutomationEvent=function createExtendedExponentialRampToValueAutomationEvent(value,endTime,insertTime){return{endTime,insertTime,type:"exponentialRampToValue",value}},createExtendedLinearRampToValueAutomationEvent=function createExtendedLinearRampToValueAutomationEvent(value,endTime,insertTime){return{endTime,insertTime,type:"linearRampToValue",value}},createSetValueAutomationEvent=function createSetValueAutomationEvent(value,startTime){return{startTime,type:"setValue",value}},createSetValueCurveAutomationEvent=function createSetValueCurveAutomationEvent(values,startTime,duration){return{duration,startTime,type:"setValueCurve",values}},getTargetValueAtTime=function getTargetValueAtTime(time,valueAtStartTime,_ref){var startTime=_ref.startTime,target=_ref.target,timeConstant=_ref.timeConstant;return target+(valueAtStartTime-target)*Math.exp((startTime-time)/timeConstant)},isExponentialRampToValueAutomationEvent=function isExponentialRampToValueAutomationEvent(automationEvent){return"exponentialRampToValue"===automationEvent.type},isLinearRampToValueAutomationEvent=function isLinearRampToValueAutomationEvent(automationEvent){return"linearRampToValue"===automationEvent.type},isAnyRampToValueAutomationEvent=function isAnyRampToValueAutomationEvent(automationEvent){return isExponentialRampToValueAutomationEvent(automationEvent)||isLinearRampToValueAutomationEvent(automationEvent)},isSetValueAutomationEvent=function isSetValueAutomationEvent(automationEvent){return"setValue"===automationEvent.type},isSetValueCurveAutomationEvent=function isSetValueCurveAutomationEvent(automationEvent){return"setValueCurve"===automationEvent.type},getValueOfAutomationEventAtIndexAtTime=function getValueOfAutomationEventAtIndexAtTime(automationEvents,index,time,defaultValue){var automationEvent=automationEvents[index];return void 0===automationEvent?defaultValue:isAnyRampToValueAutomationEvent(automationEvent)||isSetValueAutomationEvent(automationEvent)?automationEvent.value:isSetValueCurveAutomationEvent(automationEvent)?automationEvent.values[automationEvent.values.length-1]:getTargetValueAtTime(time,getValueOfAutomationEventAtIndexAtTime(automationEvents,index-1,automationEvent.startTime,defaultValue),automationEvent)},getEndTimeAndValueOfPreviousAutomationEvent=function getEndTimeAndValueOfPreviousAutomationEvent(automationEvents,index,currentAutomationEvent,nextAutomationEvent,defaultValue){return void 0===currentAutomationEvent?[nextAutomationEvent.insertTime,defaultValue]:isAnyRampToValueAutomationEvent(currentAutomationEvent)?[currentAutomationEvent.endTime,currentAutomationEvent.value]:isSetValueAutomationEvent(currentAutomationEvent)?[currentAutomationEvent.startTime,currentAutomationEvent.value]:isSetValueCurveAutomationEvent(currentAutomationEvent)?[currentAutomationEvent.startTime+currentAutomationEvent.duration,currentAutomationEvent.values[currentAutomationEvent.values.length-1]]:[currentAutomationEvent.startTime,getValueOfAutomationEventAtIndexAtTime(automationEvents,index-1,currentAutomationEvent.startTime,defaultValue)]},isCancelAndHoldAutomationEvent=function isCancelAndHoldAutomationEvent(automationEvent){return"cancelAndHold"===automationEvent.type},isCancelScheduledValuesAutomationEvent=function isCancelScheduledValuesAutomationEvent(automationEvent){return"cancelScheduledValues"===automationEvent.type},getEventTime=function getEventTime(automationEvent){return isCancelAndHoldAutomationEvent(automationEvent)||isCancelScheduledValuesAutomationEvent(automationEvent)?automationEvent.cancelTime:isExponentialRampToValueAutomationEvent(automationEvent)||isLinearRampToValueAutomationEvent(automationEvent)?automationEvent.endTime:automationEvent.startTime},getExponentialRampValueAtTime=function getExponentialRampValueAtTime(time,startTime,valueAtStartTime,_ref){var endTime=_ref.endTime,value=_ref.value;return valueAtStartTime===value?value:0<valueAtStartTime&&0<value||valueAtStartTime<0&&value<0?valueAtStartTime*Math.pow(value/valueAtStartTime,(time-startTime)/(endTime-startTime)):0},getLinearRampValueAtTime=function getLinearRampValueAtTime(time,startTime,valueAtStartTime,_ref){return valueAtStartTime+(time-startTime)/(_ref.endTime-startTime)*(_ref.value-valueAtStartTime)},interpolateValue=function interpolateValue(values,theoreticIndex){var lowerIndex=Math.floor(theoreticIndex),upperIndex=Math.ceil(theoreticIndex);return lowerIndex===upperIndex?values[lowerIndex]:(1-(theoreticIndex-lowerIndex))*values[lowerIndex]+(1-(upperIndex-theoreticIndex))*values[upperIndex]},getValueCurveValueAtTime=function getValueCurveValueAtTime(time,_ref){var duration=_ref.duration,startTime=_ref.startTime,values=_ref.values,theoreticIndex=(time-startTime)/duration*(values.length-1);return interpolateValue(values,theoreticIndex)},isSetTargetAutomationEvent=function isSetTargetAutomationEvent(automationEvent){return"setTarget"===automationEvent.type},AutomationEventList=function(_Symbol$iterator){function AutomationEventList(defaultValue){_classCallCheck__default.default(this,AutomationEventList),this._automationEvents=[],this._currenTime=0,this._defaultValue=defaultValue}return _createClass__default.default(AutomationEventList,[{key:_Symbol$iterator,value:function value(){return this._automationEvents[Symbol.iterator]()}},{key:"add",value:function add(automationEvent){var eventTime=getEventTime(automationEvent);if(isCancelAndHoldAutomationEvent(automationEvent)||isCancelScheduledValuesAutomationEvent(automationEvent)){var index=this._automationEvents.findIndex(function(currentAutomationEvent){return isCancelScheduledValuesAutomationEvent(automationEvent)&&isSetValueCurveAutomationEvent(currentAutomationEvent)?currentAutomationEvent.startTime+currentAutomationEvent.duration>=eventTime:getEventTime(currentAutomationEvent)>=eventTime}),removedAutomationEvent=this._automationEvents[index];if(-1!==index&&(this._automationEvents=this._automationEvents.slice(0,index)),isCancelAndHoldAutomationEvent(automationEvent)){var lastAutomationEvent=this._automationEvents[this._automationEvents.length-1];if(void 0!==removedAutomationEvent&&isAnyRampToValueAutomationEvent(removedAutomationEvent)){if(isSetTargetAutomationEvent(lastAutomationEvent))throw new Error("The internal list is malformed.");var startTime=isSetValueCurveAutomationEvent(lastAutomationEvent)?lastAutomationEvent.startTime+lastAutomationEvent.duration:getEventTime(lastAutomationEvent),startValue=isSetValueCurveAutomationEvent(lastAutomationEvent)?lastAutomationEvent.values[lastAutomationEvent.values.length-1]:lastAutomationEvent.value,value=isExponentialRampToValueAutomationEvent(removedAutomationEvent)?getExponentialRampValueAtTime(eventTime,startTime,startValue,removedAutomationEvent):getLinearRampValueAtTime(eventTime,startTime,startValue,removedAutomationEvent),truncatedAutomationEvent=isExponentialRampToValueAutomationEvent(removedAutomationEvent)?createExtendedExponentialRampToValueAutomationEvent(value,eventTime,this._currenTime):createExtendedLinearRampToValueAutomationEvent(value,eventTime,this._currenTime);this._automationEvents.push(truncatedAutomationEvent)}void 0!==lastAutomationEvent&&isSetTargetAutomationEvent(lastAutomationEvent)&&this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime),eventTime)),void 0!==lastAutomationEvent&&isSetValueCurveAutomationEvent(lastAutomationEvent)&&lastAutomationEvent.startTime+lastAutomationEvent.duration>eventTime&&(this._automationEvents[this._automationEvents.length-1]=createSetValueCurveAutomationEvent(new Float32Array([6,7]),lastAutomationEvent.startTime,eventTime-lastAutomationEvent.startTime))}}else{var _index=this._automationEvents.findIndex(function(currentAutomationEvent){return getEventTime(currentAutomationEvent)>eventTime}),previousAutomationEvent=-1===_index?this._automationEvents[this._automationEvents.length-1]:this._automationEvents[_index-1];if(void 0!==previousAutomationEvent&&isSetValueCurveAutomationEvent(previousAutomationEvent)&&getEventTime(previousAutomationEvent)+previousAutomationEvent.duration>eventTime)return!1;var persistentAutomationEvent=isExponentialRampToValueAutomationEvent(automationEvent)?createExtendedExponentialRampToValueAutomationEvent(automationEvent.value,automationEvent.endTime,this._currenTime):isLinearRampToValueAutomationEvent(automationEvent)?createExtendedLinearRampToValueAutomationEvent(automationEvent.value,eventTime,this._currenTime):automationEvent;if(-1===_index)this._automationEvents.push(persistentAutomationEvent);else{if(isSetValueCurveAutomationEvent(automationEvent)&&eventTime+automationEvent.duration>getEventTime(this._automationEvents[_index]))return!1;this._automationEvents.splice(_index,0,persistentAutomationEvent)}}return!0}},{key:"flush",value:function flush(time){var index=this._automationEvents.findIndex(function(currentAutomationEvent){return getEventTime(currentAutomationEvent)>time});if(index>1){var remainingAutomationEvents=this._automationEvents.slice(index-1),firstRemainingAutomationEvent=remainingAutomationEvents[0];isSetTargetAutomationEvent(firstRemainingAutomationEvent)&&remainingAutomationEvents.unshift(createSetValueAutomationEvent(getValueOfAutomationEventAtIndexAtTime(this._automationEvents,index-2,firstRemainingAutomationEvent.startTime,this._defaultValue),firstRemainingAutomationEvent.startTime)),this._automationEvents=remainingAutomationEvents}}},{key:"getValue",value:function getValue(time){if(0===this._automationEvents.length)return this._defaultValue;var indexOfNextEvent=this._automationEvents.findIndex(function(automationEvent){return getEventTime(automationEvent)>time}),nextAutomationEvent=this._automationEvents[indexOfNextEvent],indexOfCurrentEvent=(-1===indexOfNextEvent?this._automationEvents.length:indexOfNextEvent)-1,currentAutomationEvent=this._automationEvents[indexOfCurrentEvent];if(void 0!==currentAutomationEvent&&isSetTargetAutomationEvent(currentAutomationEvent)&&(void 0===nextAutomationEvent||!isAnyRampToValueAutomationEvent(nextAutomationEvent)||nextAutomationEvent.insertTime>time))return getTargetValueAtTime(time,getValueOfAutomationEventAtIndexAtTime(this._automationEvents,indexOfCurrentEvent-1,currentAutomationEvent.startTime,this._defaultValue),currentAutomationEvent);if(void 0!==currentAutomationEvent&&isSetValueAutomationEvent(currentAutomationEvent)&&(void 0===nextAutomationEvent||!isAnyRampToValueAutomationEvent(nextAutomationEvent)))return currentAutomationEvent.value;if(void 0!==currentAutomationEvent&&isSetValueCurveAutomationEvent(currentAutomationEvent)&&(void 0===nextAutomationEvent||!isAnyRampToValueAutomationEvent(nextAutomationEvent)||currentAutomationEvent.startTime+currentAutomationEvent.duration>time))return time<currentAutomationEvent.startTime+currentAutomationEvent.duration?getValueCurveValueAtTime(time,currentAutomationEvent):currentAutomationEvent.values[currentAutomationEvent.values.length-1];if(void 0!==currentAutomationEvent&&isAnyRampToValueAutomationEvent(currentAutomationEvent)&&(void 0===nextAutomationEvent||!isAnyRampToValueAutomationEvent(nextAutomationEvent)))return currentAutomationEvent.value;if(void 0!==nextAutomationEvent&&isExponentialRampToValueAutomationEvent(nextAutomationEvent)){var _getEndTimeAndValueOf=getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents,indexOfCurrentEvent,currentAutomationEvent,nextAutomationEvent,this._defaultValue),_getEndTimeAndValueOf2=_slicedToArray__default.default(_getEndTimeAndValueOf,2),startTime=_getEndTimeAndValueOf2[0],value=_getEndTimeAndValueOf2[1];return getExponentialRampValueAtTime(time,startTime,value,nextAutomationEvent)}if(void 0!==nextAutomationEvent&&isLinearRampToValueAutomationEvent(nextAutomationEvent)){var _getEndTimeAndValueOf3=getEndTimeAndValueOfPreviousAutomationEvent(this._automationEvents,indexOfCurrentEvent,currentAutomationEvent,nextAutomationEvent,this._defaultValue),_getEndTimeAndValueOf4=_slicedToArray__default.default(_getEndTimeAndValueOf3,2),_startTime=_getEndTimeAndValueOf4[0],_value=_getEndTimeAndValueOf4[1];return getLinearRampValueAtTime(time,_startTime,_value,nextAutomationEvent)}return this._defaultValue}}]),AutomationEventList}(Symbol.iterator),createCancelAndHoldAutomationEvent=function createCancelAndHoldAutomationEvent(cancelTime){return{cancelTime,type:"cancelAndHold"}},createCancelScheduledValuesAutomationEvent=function createCancelScheduledValuesAutomationEvent(cancelTime){return{cancelTime,type:"cancelScheduledValues"}},createExponentialRampToValueAutomationEvent=function createExponentialRampToValueAutomationEvent(value,endTime){return{endTime,type:"exponentialRampToValue",value}},createLinearRampToValueAutomationEvent=function createLinearRampToValueAutomationEvent(value,endTime){return{endTime,type:"linearRampToValue",value}},createSetTargetAutomationEvent=function createSetTargetAutomationEvent(target,startTime,timeConstant){return{startTime,target,timeConstant,type:"setTarget"}};exports.AutomationEventList=AutomationEventList,exports.createCancelAndHoldAutomationEvent=createCancelAndHoldAutomationEvent,exports.createCancelScheduledValuesAutomationEvent=createCancelScheduledValuesAutomationEvent,exports.createExponentialRampToValueAutomationEvent=createExponentialRampToValueAutomationEvent,exports.createLinearRampToValueAutomationEvent=createLinearRampToValueAutomationEvent,exports.createSetTargetAutomationEvent=createSetTargetAutomationEvent,exports.createSetValueAutomationEvent=createSetValueAutomationEvent,exports.createSetValueCurveAutomationEvent=createSetValueCurveAutomationEvent,Object.defineProperty(exports,"__esModule",{value:!0})}(exports,__webpack_require__("./node_modules/@babel/runtime/helpers/slicedToArray.js"),__webpack_require__("./node_modules/@babel/runtime/helpers/classCallCheck.js"),__webpack_require__("./node_modules/@babel/runtime/helpers/createClass.js"))},"./node_modules/ellipsed/lib/ellipsed.js":function(module,exports){var __WEBPACK_AMD_DEFINE_FACTORY__,__WEBPACK_AMD_DEFINE_ARRAY__,__WEBPACK_AMD_DEFINE_RESULT__;__WEBPACK_AMD_DEFINE_ARRAY__=[exports],__WEBPACK_AMD_DEFINE_FACTORY__=function(exports){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var _extends=Object.assign||function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source)Object.prototype.hasOwnProperty.call(source,key)&&(target[key]=source[key])}return target};function tokensReducer(acc,token){var el=acc.el,elStyle=acc.elStyle,elHeight=acc.elHeight,rowsLimit=acc.rowsLimit,rowsWrapped=acc.rowsWrapped,options=acc.options,oldBuffer=acc.buffer,newBuffer=oldBuffer;if(rowsWrapped===rowsLimit+1)return _extends({},acc);var textBeforeWrap=oldBuffer,newRowsWrapped=rowsWrapped,newHeight=elHeight;return el.innerHTML=newBuffer=oldBuffer.length?""+oldBuffer+options.delimiter+token+options.replaceStr:""+token+options.replaceStr,parseFloat(elStyle.height)>parseFloat(elHeight)&&(newRowsWrapped++,newHeight=elStyle.height,newRowsWrapped===rowsLimit+1)?(el.innerHTML=newBuffer="."===textBeforeWrap[textBeforeWrap.length-1]&&"..."===options.replaceStr?textBeforeWrap+"..":""+textBeforeWrap+options.replaceStr,_extends({},acc,{elHeight:newHeight,rowsWrapped:newRowsWrapped})):(el.innerHTML=newBuffer=textBeforeWrap.length?""+textBeforeWrap+options.delimiter+token:""+token,_extends({},acc,{buffer:newBuffer,elHeight:newHeight,rowsWrapped:newRowsWrapped}))}function ellipsis(){for(var selector=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",rows=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,options=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},opts=_extends({},{replaceStr:"...",responsive:!1,debounceDelay:250,delimiter:" "},options),elements=selector&&(selector instanceof NodeList?selector:1===selector.nodeType?[selector]:document.querySelectorAll(selector)),originalTexts=[],i=0;i<elements.length;i++){var el=elements[i];originalTexts[i]=el.innerHTML;var splittedText=el.innerHTML.split(opts.delimiter);el.innerHTML="";var elStyle=window.getComputedStyle(el);splittedText.reduce(tokensReducer,{el,buffer:el.innerHTML,elStyle,elHeight:0,rowsLimit:rows,rowsWrapped:0,options:opts})}if(opts.responsive){var resizeTimeout=!1,last_window_w=window.innerWidth,resizeHandler=function resizeHandler(){if(window.innerWidth!==last_window_w){last_window_w=window.innerWidth;for(var _i=0;_i<elements.length;_i++)elements[_i].innerHTML=originalTexts[_i];ellipsis(selector,rows,_extends({},options,{responsive:!1}))}},resizeListener=function resizeListener(){clearTimeout(resizeTimeout),resizeTimeout=setTimeout(resizeHandler,opts.debounceDelay)};return window.addEventListener("resize",resizeListener),resizeListener}}function disableResponsive(listener){window.removeEventListener("resize",listener)}exports.disableResponsive=disableResponsive,exports.ellipsis=ellipsis},void 0===(__WEBPACK_AMD_DEFINE_RESULT__="function"==typeof __WEBPACK_AMD_DEFINE_FACTORY__?__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports,__WEBPACK_AMD_DEFINE_ARRAY__):__WEBPACK_AMD_DEFINE_FACTORY__)||(module.exports=__WEBPACK_AMD_DEFINE_RESULT__)},"./node_modules/lodash/_baseTrim.js":(module,__unused_webpack_exports,__webpack_require__)=>{var trimmedEndIndex=__webpack_require__("./node_modules/lodash/_trimmedEndIndex.js"),reTrimStart=/^\s+/;module.exports=function baseTrim(string){return string?string.slice(0,trimmedEndIndex(string)+1).replace(reTrimStart,""):string}},"./node_modules/lodash/_trimmedEndIndex.js":module=>{var reWhitespace=/\s/;module.exports=function trimmedEndIndex(string){for(var index=string.length;index--&&reWhitespace.test(string.charAt(index)););return index}},"./node_modules/lodash/debounce.js":(module,__unused_webpack_exports,__webpack_require__)=>{var isObject=__webpack_require__("./node_modules/lodash/isObject.js"),now=__webpack_require__("./node_modules/lodash/now.js"),toNumber=__webpack_require__("./node_modules/lodash/toNumber.js"),nativeMax=Math.max,nativeMin=Math.min;module.exports=function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=!1,maxing=!1,trailing=!0;if("function"!=typeof func)throw new TypeError("Expected a function");function invokeFunc(time){var args=lastArgs,thisArg=lastThis;return lastArgs=lastThis=void 0,lastInvokeTime=time,result=func.apply(thisArg,args)}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime;return void 0===lastCallTime||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&time-lastInvokeTime>=maxWait}function timerExpired(){var time=now();if(shouldInvoke(time))return trailingEdge(time);timerId=setTimeout(timerExpired,function remainingWait(time){var timeWaiting=wait-(time-lastCallTime);return maxing?nativeMin(timeWaiting,maxWait-(time-lastInvokeTime)):timeWaiting}(time))}function trailingEdge(time){return timerId=void 0,trailing&&lastArgs?invokeFunc(time):(lastArgs=lastThis=void 0,result)}function debounced(){var time=now(),isInvoking=shouldInvoke(time);if(lastArgs=arguments,lastThis=this,lastCallTime=time,isInvoking){if(void 0===timerId)return function leadingEdge(time){return lastInvokeTime=time,timerId=setTimeout(timerExpired,wait),leading?invokeFunc(time):result}(lastCallTime);if(maxing)return clearTimeout(timerId),timerId=setTimeout(timerExpired,wait),invokeFunc(lastCallTime)}return void 0===timerId&&(timerId=setTimeout(timerExpired,wait)),result}return wait=toNumber(wait)||0,isObject(options)&&(leading=!!options.leading,maxWait=(maxing="maxWait"in options)?nativeMax(toNumber(options.maxWait)||0,wait):maxWait,trailing="trailing"in options?!!options.trailing:trailing),debounced.cancel=function cancel(){void 0!==timerId&&clearTimeout(timerId),lastInvokeTime=0,lastArgs=lastCallTime=lastThis=timerId=void 0},debounced.flush=function flush(){return void 0===timerId?result:trailingEdge(now())},debounced}},"./node_modules/lodash/now.js":(module,__unused_webpack_exports,__webpack_require__)=>{var root=__webpack_require__("./node_modules/lodash/_root.js");module.exports=function(){return root.Date.now()}},"./node_modules/lodash/toNumber.js":(module,__unused_webpack_exports,__webpack_require__)=>{var baseTrim=__webpack_require__("./node_modules/lodash/_baseTrim.js"),isObject=__webpack_require__("./node_modules/lodash/isObject.js"),isSymbol=__webpack_require__("./node_modules/lodash/isSymbol.js"),reIsBadHex=/^[-+]0x[0-9a-f]+$/i,reIsBinary=/^0b[01]+$/i,reIsOctal=/^0o[0-7]+$/i,freeParseInt=parseInt;module.exports=function toNumber(value){if("number"==typeof value)return value;if(isSymbol(value))return NaN;if(isObject(value)){var other="function"==typeof value.valueOf?value.valueOf():value;value=isObject(other)?other+"":other}if("string"!=typeof value)return 0===value?value:+value;value=baseTrim(value);var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NaN:+value}},"./node_modules/react-i18next/dist/es/withTranslation.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{C:()=>withTranslation});var defineProperty=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/defineProperty.js"),slicedToArray=__webpack_require__("./node_modules/@babel/runtime/helpers/esm/slicedToArray.js");var react=__webpack_require__("./node_modules/react/index.js"),useTranslation=__webpack_require__("./node_modules/react-i18next/dist/es/useTranslation.js"),utils=__webpack_require__("./node_modules/react-i18next/dist/es/utils.js"),_excluded=["forwardedRef"];function ownKeys(object,enumerableOnly){var keys=Object.keys(object);if(Object.getOwnPropertySymbols){var symbols=Object.getOwnPropertySymbols(object);enumerableOnly&&(symbols=symbols.filter(function(sym){return Object.getOwnPropertyDescriptor(object,sym).enumerable})),keys.push.apply(keys,symbols)}return keys}function _objectSpread(target){for(var i=1;i<arguments.length;i++){var source=null!=arguments[i]?arguments[i]:{};i%2?ownKeys(Object(source),!0).forEach(function(key){(0,defineProperty.A)(target,key,source[key])}):Object.getOwnPropertyDescriptors?Object.defineProperties(target,Object.getOwnPropertyDescriptors(source)):ownKeys(Object(source)).forEach(function(key){Object.defineProperty(target,key,Object.getOwnPropertyDescriptor(source,key))})}return target}function withTranslation(ns){var options=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return function Extend(WrappedComponent){function I18nextWithTranslation(_ref){var forwardedRef=_ref.forwardedRef,rest=function _objectWithoutProperties(e,t){if(null==e)return{};var o,r,i=function _objectWithoutPropertiesLoose(r,e){if(null==r)return{};var t={};for(var n in r)if({}.hasOwnProperty.call(r,n)){if(-1!==e.indexOf(n))continue;t[n]=r[n]}return t}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)o=n[r],-1===t.indexOf(o)&&{}.propertyIsEnumerable.call(e,o)&&(i[o]=e[o])}return i}(_ref,_excluded),_useTranslation=(0,useTranslation.B)(ns,_objectSpread(_objectSpread({},rest),{},{keyPrefix:options.keyPrefix})),_useTranslation2=(0,slicedToArray.A)(_useTranslation,3),t=_useTranslation2[0],i18n=_useTranslation2[1],ready=_useTranslation2[2],passDownProps=_objectSpread(_objectSpread({},rest),{},{t,i18n,tReady:ready});return options.withRef&&forwardedRef?passDownProps.ref=forwardedRef:!options.withRef&&forwardedRef&&(passDownProps.forwardedRef=forwardedRef),(0,react.createElement)(WrappedComponent,passDownProps)}I18nextWithTranslation.displayName="withI18nextTranslation(".concat((0,utils.Mn)(WrappedComponent),")"),I18nextWithTranslation.WrappedComponent=WrappedComponent;return options.withRef?(0,react.forwardRef)(function forwardRef(props,ref){return(0,react.createElement)(I18nextWithTranslation,Object.assign({},props,{forwardedRef:ref}))}):I18nextWithTranslation}}},"./node_modules/standardized-audio-context/build/es2019/module.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{Ut:()=>audioContextConstructor});var bundle=__webpack_require__("./node_modules/automation-events/build/es5/bundle.js");const ACTIVE_AUDIO_NODE_STORE=new WeakSet,AUDIO_NODE_CONNECTIONS_STORE=new WeakMap,AUDIO_NODE_STORE=new WeakMap,AUDIO_PARAM_CONNECTIONS_STORE=new WeakMap,AUDIO_PARAM_STORE=new WeakMap,CONTEXT_STORE=new WeakMap,EVENT_LISTENERS=new WeakMap,CYCLE_COUNTERS=new WeakMap,NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS=new WeakMap,NODE_TO_PROCESSOR_MAPS=new WeakMap,handler={construct:()=>handler},IMPORT_STATEMENT_REGEX=/^import(?:(?:[\s]+[\w]+|(?:[\s]+[\w]+[\s]*,)?[\s]*\{[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?(?:[\s]*,[\s]*[\w]+(?:[\s]+as[\s]+[\w]+)?)*[\s]*}|(?:[\s]+[\w]+[\s]*,)?[\s]*\*[\s]+as[\s]+[\w]+)[\s]+from)?(?:[\s]*)("([^"\\]|\\.)+"|'([^'\\]|\\.)+')(?:[\s]*);?/,splitImportStatements=(source,url)=>{const importStatements=[];let sourceWithoutImportStatements=source.replace(/^[\s]+/,""),result=sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);for(;null!==result;){const unresolvedUrl=result[1].slice(1,-1),importStatementWithResolvedUrl=result[0].replace(/([\s]+)?;?$/,"").replace(unresolvedUrl,new URL(unresolvedUrl,url).toString());importStatements.push(importStatementWithResolvedUrl),sourceWithoutImportStatements=sourceWithoutImportStatements.slice(result[0].length).replace(/^[\s]+/,""),result=sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX)}return[importStatements.join(";"),sourceWithoutImportStatements]},verifyParameterDescriptors=parameterDescriptors=>{if(void 0!==parameterDescriptors&&!Array.isArray(parameterDescriptors))throw new TypeError("The parameterDescriptors property of given value for processorCtor is not an array.")},verifyProcessorCtor=processorCtor=>{if(!(constructible=>{try{new new Proxy(constructible,handler)}catch{return!1}return!0})(processorCtor))throw new TypeError("The given value for processorCtor should be a constructor.");if(null===processorCtor.prototype||"object"!=typeof processorCtor.prototype)throw new TypeError("The given value for processorCtor should have a prototype.")},getValueForKey=(map,key)=>{const value=map.get(key);if(void 0===value)throw new Error("A value with the given key could not be found.");return value},pickElementFromSet=(set,predicate)=>{const matchingElements=Array.from(set).filter(predicate);if(matchingElements.length>1)throw Error("More than one element was found.");if(0===matchingElements.length)throw Error("No element was found.");const[matchingElement]=matchingElements;return set.delete(matchingElement),matchingElement},deletePassiveInputConnectionToAudioNode=(passiveInputs,source,output,input)=>{const passiveInputConnections=getValueForKey(passiveInputs,source),matchingConnection=pickElementFromSet(passiveInputConnections,passiveInputConnection=>passiveInputConnection[0]===output&&passiveInputConnection[1]===input);return 0===passiveInputConnections.size&&passiveInputs.delete(source),matchingConnection},getEventListenersOfAudioNode=audioNode=>getValueForKey(EVENT_LISTENERS,audioNode),setInternalStateToActive=audioNode=>{if(ACTIVE_AUDIO_NODE_STORE.has(audioNode))throw new Error("The AudioNode is already stored.");ACTIVE_AUDIO_NODE_STORE.add(audioNode),getEventListenersOfAudioNode(audioNode).forEach(eventListener=>eventListener(!0))},isAudioWorkletNode=audioNode=>"port"in audioNode,setInternalStateToPassive=audioNode=>{if(!ACTIVE_AUDIO_NODE_STORE.has(audioNode))throw new Error("The AudioNode is not stored.");ACTIVE_AUDIO_NODE_STORE.delete(audioNode),getEventListenersOfAudioNode(audioNode).forEach(eventListener=>eventListener(!1))},setInternalStateToPassiveWhenNecessary=(audioNode,activeInputs)=>{!isAudioWorkletNode(audioNode)&&activeInputs.every(connections=>0===connections.size)&&setInternalStateToPassive(audioNode)},DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",fftSize:2048,maxDecibels:-30,minDecibels:-100,smoothingTimeConstant:.8},isOwnedByContext=(nativeAudioNode,nativeContext)=>nativeAudioNode.context===nativeContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport=nativeAudioBuffer=>{try{nativeAudioBuffer.copyToChannel(new Float32Array(1),0,-1)}catch{return!1}return!0},createIndexSizeError=()=>new DOMException("","IndexSizeError"),wrapAudioBufferGetChannelDataMethod=audioBuffer=>{var getChannelData;audioBuffer.getChannelData=(getChannelData=audioBuffer.getChannelData,channel=>{try{return getChannelData.call(audioBuffer,channel)}catch(err){if(12===err.code)throw createIndexSizeError();throw err}})},audio_buffer_constructor_DEFAULT_OPTIONS={numberOfChannels:1},MOST_NEGATIVE_SINGLE_FLOAT=-34028234663852886e22,MOST_POSITIVE_SINGLE_FLOAT=-MOST_NEGATIVE_SINGLE_FLOAT,isActiveAudioNode=audioNode=>ACTIVE_AUDIO_NODE_STORE.has(audioNode),audio_buffer_source_node_constructor_DEFAULT_OPTIONS={buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1},getAudioNodeConnections=audioNode=>getValueForKey(AUDIO_NODE_CONNECTIONS_STORE,audioNode),getAudioParamConnections=audioParam=>getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE,audioParam),deactivateActiveAudioNodeInputConnections=(audioNode,trace)=>{const{activeInputs}=getAudioNodeConnections(audioNode);activeInputs.forEach(connections=>connections.forEach(([source])=>{trace.includes(audioNode)||deactivateActiveAudioNodeInputConnections(source,[...trace,audioNode])}));const audioParams=(audioNode=>"playbackRate"in audioNode)(audioNode)?[audioNode.playbackRate]:isAudioWorkletNode(audioNode)?Array.from(audioNode.parameters.values()):(audioNode=>"frequency"in audioNode&&"gain"in audioNode)(audioNode)?[audioNode.Q,audioNode.detune,audioNode.frequency,audioNode.gain]:(audioNode=>"offset"in audioNode)(audioNode)?[audioNode.offset]:(audioNode=>!("frequency"in audioNode)&&"gain"in audioNode)(audioNode)?[audioNode.gain]:(audioNode=>"detune"in audioNode&&"frequency"in audioNode)(audioNode)?[audioNode.detune,audioNode.frequency]:(audioNode=>"pan"in audioNode)(audioNode)?[audioNode.pan]:[];for(const audioParam of audioParams){const audioParamConnections=getAudioParamConnections(audioParam);void 0!==audioParamConnections&&audioParamConnections.activeInputs.forEach(([source])=>deactivateActiveAudioNodeInputConnections(source,trace))}isActiveAudioNode(audioNode)&&setInternalStateToPassive(audioNode)},deactivateAudioGraph=context=>{deactivateActiveAudioNodeInputConnections(context.destination,[])},isValidLatencyHint=latencyHint=>void 0===latencyHint||"number"==typeof latencyHint||"string"==typeof latencyHint&&("balanced"===latencyHint||"interactive"===latencyHint||"playback"===latencyHint),isAudioNode=audioNodeOrAudioParam=>"context"in audioNodeOrAudioParam,isAudioNodeOutputConnection=outputConnection=>isAudioNode(outputConnection[0]),insertElementInSet=(set,element,predicate,ignoreDuplicates)=>{for(const lmnt of set)if(predicate(lmnt)){if(ignoreDuplicates)return!1;throw Error("The set contains at least one similar element.")}return set.add(element),!0},addActiveInputConnectionToAudioParam=(activeInputs,source,[output,eventListener],ignoreDuplicates)=>{insertElementInSet(activeInputs,[source,output,eventListener],activeInputConnection=>activeInputConnection[0]===source&&activeInputConnection[1]===output,ignoreDuplicates)},addPassiveInputConnectionToAudioParam=(passiveInputs,[source,output,eventListener],ignoreDuplicates)=>{const passiveInputConnections=passiveInputs.get(source);void 0===passiveInputConnections?passiveInputs.set(source,new Set([[output,eventListener]])):insertElementInSet(passiveInputConnections,[output,eventListener],passiveInputConnection=>passiveInputConnection[0]===output,ignoreDuplicates)},isNativeAudioNodeFaker=nativeAudioNodeOrNativeAudioNodeFaker=>"inputs"in nativeAudioNodeOrNativeAudioNodeFaker,connectNativeAudioNodeToNativeAudioNode=(nativeSourceAudioNode,nativeDestinationAudioNode,output,input)=>{if(isNativeAudioNodeFaker(nativeDestinationAudioNode)){const fakeNativeDestinationAudioNode=nativeDestinationAudioNode.inputs[input];return nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode,output,0),[fakeNativeDestinationAudioNode,output,0]}return nativeSourceAudioNode.connect(nativeDestinationAudioNode,output,input),[nativeDestinationAudioNode,output,input]},deleteActiveInputConnection=(activeInputConnections,source,output)=>{for(const activeInputConnection of activeInputConnections)if(activeInputConnection[0]===source&&activeInputConnection[1]===output)return activeInputConnections.delete(activeInputConnection),activeInputConnection;return null},deleteEventListenerOfAudioNode=(audioNode,eventListener)=>{if(!getEventListenersOfAudioNode(audioNode).delete(eventListener))throw new Error("Missing the expected event listener.")},deletePassiveInputConnectionToAudioParam=(passiveInputs,source,output)=>{const passiveInputConnections=getValueForKey(passiveInputs,source),matchingConnection=pickElementFromSet(passiveInputConnections,passiveInputConnection=>passiveInputConnection[0]===output);return 0===passiveInputConnections.size&&passiveInputs.delete(source),matchingConnection},disconnectNativeAudioNodeFromNativeAudioNode=(nativeSourceAudioNode,nativeDestinationAudioNode,output,input)=>{isNativeAudioNodeFaker(nativeDestinationAudioNode)?nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input],output,0):nativeSourceAudioNode.disconnect(nativeDestinationAudioNode,output,input)},getNativeAudioNode=audioNode=>getValueForKey(AUDIO_NODE_STORE,audioNode),getNativeAudioParam=audioParam=>getValueForKey(AUDIO_PARAM_STORE,audioParam),isPartOfACycle=audioNode=>CYCLE_COUNTERS.has(audioNode),isPassiveAudioNode=audioNode=>!ACTIVE_AUDIO_NODE_STORE.has(audioNode),testAudioNodeDisconnectMethodSupport=(nativeAudioContext,nativeAudioWorkletNodeConstructor)=>new Promise(resolve=>{if(null!==nativeAudioWorkletNodeConstructor)resolve(!0);else{const analyzer=nativeAudioContext.createScriptProcessor(256,1,1),dummy=nativeAudioContext.createGain(),ones=nativeAudioContext.createBuffer(1,2,44100),channelData=ones.getChannelData(0);channelData[0]=1,channelData[1]=1;const source=nativeAudioContext.createBufferSource();source.buffer=ones,source.loop=!0,source.connect(analyzer).connect(nativeAudioContext.destination),source.connect(dummy),source.disconnect(dummy),analyzer.onaudioprocess=event=>{const chnnlDt=event.inputBuffer.getChannelData(0);Array.prototype.some.call(chnnlDt,sample=>1===sample)?resolve(!0):resolve(!1),source.stop(),analyzer.onaudioprocess=null,source.disconnect(analyzer),analyzer.disconnect(nativeAudioContext.destination)},source.start()}}),visitEachAudioNodeOnce=(cycles,visitor)=>{const counts=new Map;for(const cycle of cycles)for(const audioNode of cycle){const count=counts.get(audioNode);counts.set(audioNode,void 0===count?1:count+1)}counts.forEach((count,audioNode)=>visitor(audioNode,count))},isNativeAudioNode=nativeAudioNodeOrAudioParam=>"context"in nativeAudioNodeOrAudioParam,wrapAudioNodeDisconnectMethod=nativeAudioNode=>{const connections=new Map;var connect,disconnect;nativeAudioNode.connect=(connect=nativeAudioNode.connect.bind(nativeAudioNode),(destination,output=0,input=0)=>{const returnValue=isNativeAudioNode(destination)?connect(destination,output,input):connect(destination,output),connectionsToDestination=connections.get(destination);return void 0===connectionsToDestination?connections.set(destination,[{input,output}]):connectionsToDestination.every(connection=>connection.input!==input||connection.output!==output)&&connectionsToDestination.push({input,output}),returnValue}),nativeAudioNode.disconnect=(disconnect=nativeAudioNode.disconnect,(destinationOrOutput,output,input)=>{if(disconnect.apply(nativeAudioNode),void 0===destinationOrOutput)connections.clear();else if("number"==typeof destinationOrOutput)for(const[destination,connectionsToDestination]of connections){const filteredConnections=connectionsToDestination.filter(connection=>connection.output!==destinationOrOutput);0===filteredConnections.length?connections.delete(destination):connections.set(destination,filteredConnections)}else if(connections.has(destinationOrOutput))if(void 0===output)connections.delete(destinationOrOutput);else{const connectionsToDestination=connections.get(destinationOrOutput);if(void 0!==connectionsToDestination){const filteredConnections=connectionsToDestination.filter(connection=>connection.output!==output&&(connection.input!==input||void 0===input));0===filteredConnections.length?connections.delete(destinationOrOutput):connections.set(destinationOrOutput,filteredConnections)}}for(const[destination,connectionsToDestination]of connections)connectionsToDestination.forEach(connection=>{isNativeAudioNode(destination)?nativeAudioNode.connect(destination,connection.output,connection.input):nativeAudioNode.connect(destination,connection.output)})})},addConnectionToAudioParamOfAudioContext=(source,destination,output,isOffline)=>{const{activeInputs,passiveInputs}=getAudioParamConnections(destination),{outputs}=getAudioNodeConnections(source),eventListeners=getEventListenersOfAudioNode(source),eventListener=isActive=>{const nativeAudioNode=getNativeAudioNode(source),nativeAudioParam=getNativeAudioParam(destination);if(isActive){const partialConnection=deletePassiveInputConnectionToAudioParam(passiveInputs,source,output);addActiveInputConnectionToAudioParam(activeInputs,source,partialConnection,!1),isOffline||isPartOfACycle(source)||nativeAudioNode.connect(nativeAudioParam,output)}else{const partialConnection=((activeInputs,source,output)=>pickElementFromSet(activeInputs,activeInputConnection=>activeInputConnection[0]===source&&activeInputConnection[1]===output))(activeInputs,source,output);addPassiveInputConnectionToAudioParam(passiveInputs,partialConnection,!1),isOffline||isPartOfACycle(source)||nativeAudioNode.disconnect(nativeAudioParam,output)}};return!!insertElementInSet(outputs,[destination,output],outputConnection=>outputConnection[0]===destination&&outputConnection[1]===output,!0)&&(eventListeners.add(eventListener),isActiveAudioNode(source)?addActiveInputConnectionToAudioParam(activeInputs,source,[output,eventListener],!0):addPassiveInputConnectionToAudioParam(passiveInputs,[source,output,eventListener],!0),!0)},deleteInputsOfAudioNode=(source,isOffline,destination,output,input)=>{const[listener,isActive]=((source,destination,output,input)=>{const{activeInputs,passiveInputs}=getAudioNodeConnections(destination),activeInputConnection=deleteActiveInputConnection(activeInputs[input],source,output);if(null===activeInputConnection)return[deletePassiveInputConnectionToAudioNode(passiveInputs,source,output,input)[2],!1];return[activeInputConnection[2],!0]})(source,destination,output,input);if(null!==listener&&(deleteEventListenerOfAudioNode(source,listener),!isActive||isOffline||isPartOfACycle(source)||disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source),getNativeAudioNode(destination),output,input)),isActiveAudioNode(destination)){const{activeInputs}=getAudioNodeConnections(destination);setInternalStateToPassiveWhenNecessary(destination,activeInputs)}},deleteInputsOfAudioParam=(source,isOffline,destination,output)=>{const[listener,isActive]=((source,destination,output)=>{const{activeInputs,passiveInputs}=getAudioParamConnections(destination),activeInputConnection=deleteActiveInputConnection(activeInputs,source,output);if(null===activeInputConnection)return[deletePassiveInputConnectionToAudioParam(passiveInputs,source,output)[1],!1];return[activeInputConnection[2],!0]})(source,destination,output);null!==listener&&(deleteEventListenerOfAudioNode(source,listener),!isActive||isOffline||isPartOfACycle(source)||getNativeAudioNode(source).disconnect(getNativeAudioParam(destination),output))};class ReadOnlyMap{constructor(parameters){this._map=new Map(parameters)}get size(){return this._map.size}entries(){return this._map.entries()}forEach(callback,thisArg=null){return this._map.forEach((value,key)=>callback.call(thisArg,value,key,this))}get(name){return this._map.get(name)}has(name){return this._map.has(name)}keys(){return this._map.keys()}values(){return this._map.values()}}const audio_worklet_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:1,numberOfOutputs:1,parameterData:{},processorOptions:{}};function copyFromChannel(audioBuffer,parent,key,channelNumber,bufferOffset){if("function"==typeof audioBuffer.copyFromChannel)0===parent[key].byteLength&&(parent[key]=new Float32Array(128)),audioBuffer.copyFromChannel(parent[key],channelNumber,bufferOffset);else{const channelData=audioBuffer.getChannelData(channelNumber);if(0===parent[key].byteLength)parent[key]=channelData.slice(bufferOffset,bufferOffset+128);else{const slicedInput=new Float32Array(channelData.buffer,bufferOffset*Float32Array.BYTES_PER_ELEMENT,128);parent[key].set(slicedInput)}}}const copyToChannel=(audioBuffer,parent,key,channelNumber,bufferOffset)=>{"function"==typeof audioBuffer.copyToChannel?0!==parent[key].byteLength&&audioBuffer.copyToChannel(parent[key],channelNumber,bufferOffset):0!==parent[key].byteLength&&audioBuffer.getChannelData(channelNumber).set(parent[key],bufferOffset)},createNestedArrays=(x,y)=>{const arrays=[];for(let i=0;i<x;i+=1){const array=[],length="number"==typeof y?y:y[i];for(let j=0;j<length;j+=1)array.push(new Float32Array(128));arrays.push(array)}return arrays},processBuffer=async(proxy,renderedBuffer,nativeOfflineAudioContext,options,outputChannelCount,processorConstructor,exposeCurrentFrameAndCurrentTime)=>{const length=null===renderedBuffer?128*Math.ceil(proxy.context.length/128):renderedBuffer.length,numberOfInputChannels=options.channelCount*options.numberOfInputs,numberOfOutputChannels=outputChannelCount.reduce((sum,value)=>sum+value,0),processedBuffer=0===numberOfOutputChannels?null:nativeOfflineAudioContext.createBuffer(numberOfOutputChannels,length,nativeOfflineAudioContext.sampleRate);if(void 0===processorConstructor)throw new Error("Missing the processor constructor.");const audioNodeConnections=getAudioNodeConnections(proxy),audioWorkletProcessor=await((nativeOfflineAudioContext,proxy)=>{const nodeToProcessorMap=getValueForKey(NODE_TO_PROCESSOR_MAPS,nativeOfflineAudioContext),nativeAudioWorkletNode=getNativeAudioNode(proxy);return getValueForKey(nodeToProcessorMap,nativeAudioWorkletNode)})(nativeOfflineAudioContext,proxy),inputs=createNestedArrays(options.numberOfInputs,options.channelCount),outputs=createNestedArrays(options.numberOfOutputs,outputChannelCount),parameters=Array.from(proxy.parameters.keys()).reduce((prmtrs,name)=>({...prmtrs,[name]:new Float32Array(128)}),{});for(let i=0;i<length;i+=128){if(options.numberOfInputs>0&&null!==renderedBuffer)for(let j=0;j<options.numberOfInputs;j+=1)for(let k=0;k<options.channelCount;k+=1)copyFromChannel(renderedBuffer,inputs[j],k,k,i);void 0!==processorConstructor.parameterDescriptors&&null!==renderedBuffer&&processorConstructor.parameterDescriptors.forEach(({name},index)=>{copyFromChannel(renderedBuffer,parameters,name,numberOfInputChannels+index,i)});for(let j=0;j<options.numberOfInputs;j+=1)for(let k=0;k<outputChannelCount[j];k+=1)0===outputs[j][k].byteLength&&(outputs[j][k]=new Float32Array(128));try{const potentiallyEmptyInputs=inputs.map((input,index)=>0===audioNodeConnections.activeInputs[index].size?[]:input),activeSourceFlag=exposeCurrentFrameAndCurrentTime(i/nativeOfflineAudioContext.sampleRate,nativeOfflineAudioContext.sampleRate,()=>audioWorkletProcessor.process(potentiallyEmptyInputs,outputs,parameters));if(null!==processedBuffer)for(let j=0,outputChannelSplitterNodeOutput=0;j<options.numberOfOutputs;j+=1){for(let k=0;k<outputChannelCount[j];k+=1)copyToChannel(processedBuffer,outputs[j],k,outputChannelSplitterNodeOutput+k,i);outputChannelSplitterNodeOutput+=outputChannelCount[j]}if(!activeSourceFlag)break}catch(error){proxy.dispatchEvent(new ErrorEvent("processorerror",{colno:error.colno,filename:error.filename,lineno:error.lineno,message:error.message}));break}}return processedBuffer},biquad_filter_node_constructor_DEFAULT_OPTIONS={Q:1,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:350,gain:0,type:"lowpass"},channel_merger_node_constructor_DEFAULT_OPTIONS={channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6},channel_splitter_node_constructor_DEFAULT_OPTIONS={channelCount:6,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:6},constant_source_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",offset:1},convolver_node_constructor_DEFAULT_OPTIONS={buffer:null,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",disableNormalization:!1},detachArrayBuffer=arrayBuffer=>{const{port1,port2}=new MessageChannel;return new Promise(resolve=>{const closeAndResolve=()=>{port2.onmessage=null,port1.close(),port2.close(),resolve()};port2.onmessage=()=>closeAndResolve();try{port1.postMessage(arrayBuffer,[arrayBuffer])}finally{closeAndResolve()}})},delay_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",delayTime:0,maxDelayTime:1},getOutputAudioNodeAtIndex=(createIndexSizeError,outputAudioNodes,output)=>{const outputAudioNode=outputAudioNodes[output];if(void 0===outputAudioNode)throw createIndexSizeError();return outputAudioNode},dynamics_compressor_node_constructor_DEFAULT_OPTIONS={attack:.003,channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",knee:30,ratio:12,release:.25,threshold:-24},gain_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",gain:1},createInvalidStateError=()=>new DOMException("","InvalidStateError"),createInvalidAccessError=()=>new DOMException("","InvalidAccessError"),iir_filter_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers"},filterBuffer=(feedback,feedbackLength,feedforward,feedforwardLength,minLength,xBuffer,yBuffer,bufferIndex,bufferLength,input,output)=>{const inputLength=input.length;let i=bufferIndex;for(let j=0;j<inputLength;j+=1){let y=feedforward[0]*input[j];for(let k=1;k<minLength;k+=1){const x=i-k&bufferLength-1;y+=feedforward[k]*xBuffer[x],y-=feedback[k]*yBuffer[x]}for(let k=minLength;k<feedforwardLength;k+=1)y+=feedforward[k]*xBuffer[i-k&bufferLength-1];for(let k=minLength;k<feedbackLength;k+=1)y-=feedback[k]*yBuffer[i-k&bufferLength-1];xBuffer[i]=input[j],yBuffer[i]=y,i=i+1&bufferLength-1,output[j]=y}return i},media_stream_audio_destination_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers"},testPromiseSupport=nativeContext=>{const uint32Array=new Uint32Array([1179011410,40,1163280727,544501094,16,131073,44100,176400,1048580,1635017060,4,0]);try{const promise=nativeContext.decodeAudioData(uint32Array.buffer,()=>{});return void 0!==promise&&(promise.catch(()=>{}),!0)}catch{}return!1},minimal_offline_audio_context_constructor_DEFAULT_OPTIONS={numberOfChannels:1},assignNativeAudioNodeOption=(nativeAudioNode,options,option)=>{const value=options[option];void 0!==value&&value!==nativeAudioNode[option]&&(nativeAudioNode[option]=value)},assignNativeAudioNodeOptions=(nativeAudioNode,options)=>{assignNativeAudioNodeOption(nativeAudioNode,options,"channelCount"),assignNativeAudioNodeOption(nativeAudioNode,options,"channelCountMode"),assignNativeAudioNodeOption(nativeAudioNode,options,"channelInterpretation")},testAnalyserNodeGetFloatTimeDomainDataMethodSupport=nativeAnalyserNode=>"function"==typeof nativeAnalyserNode.getFloatTimeDomainData,assignNativeAudioNodeAudioParamValue=(nativeAudioNode,options,audioParam)=>{const value=options[audioParam];void 0!==value&&value!==nativeAudioNode[audioParam].value&&(nativeAudioNode[audioParam].value=value)},wrapAudioScheduledSourceNodeStartMethodNegativeParameters=nativeAudioScheduledSourceNode=>{var start;nativeAudioScheduledSourceNode.start=(start=nativeAudioScheduledSourceNode.start,(when=0,offset=0,duration)=>{if("number"==typeof duration&&duration<0||offset<0||when<0)throw new RangeError("The parameters can't be negative.");start.call(nativeAudioScheduledSourceNode,when,offset,duration)})},wrapAudioScheduledSourceNodeStopMethodNegativeParameters=nativeAudioScheduledSourceNode=>{var stop;nativeAudioScheduledSourceNode.stop=(stop=nativeAudioScheduledSourceNode.stop,(when=0)=>{if(when<0)throw new RangeError("The parameter can't be negative.");stop.call(nativeAudioScheduledSourceNode,when)})},computeBufferSize=(baseLatency,sampleRate)=>null===baseLatency?512:Math.max(512,Math.min(16384,Math.pow(2,Math.round(Math.log2(baseLatency*sampleRate))))),createAudioWorkletProcessorPromise=async(processorConstructor,audioWorkletNodeOptions)=>{const clonedAudioWorkletNodeOptions=await(audioWorkletNodeOptions=>new Promise((resolve,reject)=>{const{port1,port2}=new MessageChannel;port1.onmessage=({data})=>{port1.close(),port2.close(),resolve(data)},port1.onmessageerror=({data})=>{port1.close(),port2.close(),reject(data)},port2.postMessage(audioWorkletNodeOptions)}))(audioWorkletNodeOptions);return new processorConstructor(clonedAudioWorkletNodeOptions)},createNativeBiquadFilterNode=(nativeContext,options)=>{const nativeBiquadFilterNode=nativeContext.createBiquadFilter();return assignNativeAudioNodeOptions(nativeBiquadFilterNode,options),assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode,options,"Q"),assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode,options,"detune"),assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode,options,"frequency"),assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode,options,"gain"),assignNativeAudioNodeOption(nativeBiquadFilterNode,options,"type"),nativeBiquadFilterNode},createNativeChannelSplitterNode=(nativeContext,options)=>{const nativeChannelSplitterNode=nativeContext.createChannelSplitter(options.numberOfOutputs);return assignNativeAudioNodeOptions(nativeChannelSplitterNode,options),(channelSplitterNode=>{const channelCount=channelSplitterNode.numberOfOutputs;Object.defineProperty(channelSplitterNode,"channelCount",{get:()=>channelCount,set:value=>{if(value!==channelCount)throw createInvalidStateError()}}),Object.defineProperty(channelSplitterNode,"channelCountMode",{get:()=>"explicit",set:value=>{if("explicit"!==value)throw createInvalidStateError()}}),Object.defineProperty(channelSplitterNode,"channelInterpretation",{get:()=>"discrete",set:value=>{if("discrete"!==value)throw createInvalidStateError()}})})(nativeChannelSplitterNode),nativeChannelSplitterNode},interceptConnections=(original,interceptor)=>(original.connect=interceptor.connect.bind(interceptor),original.disconnect=interceptor.disconnect.bind(interceptor),original),createNativeDelayNode=(nativeContext,options)=>{const nativeDelayNode=nativeContext.createDelay(options.maxDelayTime);return assignNativeAudioNodeOptions(nativeDelayNode,options),assignNativeAudioNodeAudioParamValue(nativeDelayNode,options,"delayTime"),nativeDelayNode},createNativeGainNode=(nativeContext,options)=>{const nativeGainNode=nativeContext.createGain();return assignNativeAudioNodeOptions(nativeGainNode,options),assignNativeAudioNodeAudioParamValue(nativeGainNode,options,"gain"),nativeGainNode};function divide(a,b){const denominator=b[0]*b[0]+b[1]*b[1];return[(a[0]*b[0]+a[1]*b[1])/denominator,(a[1]*b[0]-a[0]*b[1])/denominator]}function multiply(a,b){return[a[0]*b[0]-a[1]*b[1],a[0]*b[1]+a[1]*b[0]]}function evaluatePolynomial(coefficient,z){let result=[0,0];for(let i=coefficient.length-1;i>=0;i-=1)result=multiply(result,z),result[0]+=coefficient[i];return result}const createNativeScriptProcessorNode=(nativeContext,bufferSize,numberOfInputChannels,numberOfOutputChannels)=>nativeContext.createScriptProcessor(bufferSize,numberOfInputChannels,numberOfOutputChannels),createNotSupportedError=()=>new DOMException("","NotSupportedError"),offline_audio_context_constructor_DEFAULT_OPTIONS={numberOfChannels:1},oscillator_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",detune:0,frequency:440,periodicWave:void 0,type:"sine"},panner_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"clamped-max",channelInterpretation:"speakers",coneInnerAngle:360,coneOuterAngle:360,coneOuterGain:0,distanceModel:"inverse",maxDistance:1e4,orientationX:1,orientationY:0,orientationZ:0,panningModel:"equalpower",positionX:0,positionY:0,positionZ:0,refDistance:1,rolloffFactor:1},periodic_wave_constructor_DEFAULT_OPTIONS={disableNormalization:!1},stereo_panner_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"explicit",channelInterpretation:"speakers",pan:0},createUnknownError=()=>new DOMException("","UnknownError"),wave_shaper_node_constructor_DEFAULT_OPTIONS={channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",curve:null,oversample:"none"},getFirstSample=(audioBuffer,buffer,channelNumber)=>void 0===audioBuffer.copyFromChannel?audioBuffer.getChannelData(channelNumber)[0]:(audioBuffer.copyFromChannel(buffer,channelNumber),buffer[0]),isDCCurve=curve=>{if(null===curve)return!1;const length=curve.length;return length%2!=0?0!==curve[Math.floor(length/2)]:curve[length/2-1]+curve[length/2]!==0},overwriteAccessors=(object,property,createGetter,createSetter)=>{let prototype=object;for(;!prototype.hasOwnProperty(property);)prototype=Object.getPrototypeOf(prototype);const{get,set}=Object.getOwnPropertyDescriptor(prototype,property);Object.defineProperty(object,property,{get:createGetter(get),set:createSetter(set)})},setValueAtTimeUntilPossible=(audioParam,value,startTime)=>{try{audioParam.setValueAtTime(value,startTime)}catch(err){if(9!==err.code)throw err;setValueAtTimeUntilPossible(audioParam,value,startTime+1e-7)}},testAudioScheduledSourceNodeStartMethodNegativeParametersSupport=nativeContext=>{const nativeAudioBufferSourceNode=nativeContext.createOscillator();try{nativeAudioBufferSourceNode.start(-1)}catch(err){return err instanceof RangeError}return!1},testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport=nativeContext=>{const nativeAudioBuffer=nativeContext.createBuffer(1,1,44100),nativeAudioBufferSourceNode=nativeContext.createBufferSource();nativeAudioBufferSourceNode.buffer=nativeAudioBuffer,nativeAudioBufferSourceNode.start(),nativeAudioBufferSourceNode.stop();try{return nativeAudioBufferSourceNode.stop(),!0}catch{return!1}},testAudioScheduledSourceNodeStopMethodNegativeParametersSupport=nativeContext=>{const nativeAudioBufferSourceNode=nativeContext.createOscillator();try{nativeAudioBufferSourceNode.stop(-1)}catch(err){return err instanceof RangeError}return!1},wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls=(nativeAudioScheduledSourceNode,nativeContext)=>{const nativeGainNode=nativeContext.createGain();nativeAudioScheduledSourceNode.connect(nativeGainNode);const disconnectGainNode=(disconnect=nativeAudioScheduledSourceNode.disconnect,()=>{disconnect.call(nativeAudioScheduledSourceNode,nativeGainNode),nativeAudioScheduledSourceNode.removeEventListener("ended",disconnectGainNode)});var disconnect;nativeAudioScheduledSourceNode.addEventListener("ended",disconnectGainNode),interceptConnections(nativeAudioScheduledSourceNode,nativeGainNode),nativeAudioScheduledSourceNode.stop=(stop=>{let isStopped=!1;return(when=0)=>{if(isStopped)try{stop.call(nativeAudioScheduledSourceNode,when)}catch{nativeGainNode.gain.setValueAtTime(0,when)}else stop.call(nativeAudioScheduledSourceNode,when),isStopped=!0}})(nativeAudioScheduledSourceNode.stop)},wrapEventListener=(target,eventListener)=>event=>{const descriptor={value:target};return Object.defineProperties(event,{currentTarget:descriptor,target:descriptor}),"function"==typeof eventListener?eventListener.call(target,event):eventListener.handleEvent.call(target,event)},addActiveInputConnectionToAudioNode=(insertElementInSet=>(activeInputs,source,[output,input,eventListener],ignoreDuplicates)=>{insertElementInSet(activeInputs[input],[source,output,eventListener],activeInputConnection=>activeInputConnection[0]===source&&activeInputConnection[1]===output,ignoreDuplicates)})(insertElementInSet),addPassiveInputConnectionToAudioNode=(insertElementInSet=>(passiveInputs,input,[source,output,eventListener],ignoreDuplicates)=>{const passiveInputConnections=passiveInputs.get(source);void 0===passiveInputConnections?passiveInputs.set(source,new Set([[output,input,eventListener]])):insertElementInSet(passiveInputConnections,[output,input,eventListener],passiveInputConnection=>passiveInputConnection[0]===output&&passiveInputConnection[1]===input,ignoreDuplicates)})(insertElementInSet),deleteActiveInputConnectionToAudioNode=(pickElementFromSet=>(activeInputs,source,output,input)=>pickElementFromSet(activeInputs[input],activeInputConnection=>activeInputConnection[0]===source&&activeInputConnection[1]===output))(pickElementFromSet),audioNodeTailTimeStore=new WeakMap,getAudioNodeTailTime=(audioNodeTailTimeStore=>audioNode=>{var _a;return null!==(_a=audioNodeTailTimeStore.get(audioNode))&&void 0!==_a?_a:0})(audioNodeTailTimeStore),cacheTestResult=(ongoingTests=new Map,testResults=new WeakMap,(tester,test)=>{const cachedTestResult=testResults.get(tester);if(void 0!==cachedTestResult)return cachedTestResult;const ongoingTest=ongoingTests.get(tester);if(void 0!==ongoingTest)return ongoingTest;try{const synchronousTestResult=test();return synchronousTestResult instanceof Promise?(ongoingTests.set(tester,synchronousTestResult),synchronousTestResult.catch(()=>!1).then(finalTestResult=>(ongoingTests.delete(tester),testResults.set(tester,finalTestResult),finalTestResult))):(testResults.set(tester,synchronousTestResult),synchronousTestResult)}catch{return testResults.set(tester,!1),!1}});var ongoingTests,testResults;const module_window="undefined"==typeof window?null:window,createNativeAnalyserNode=((cacheTestResult,createIndexSizeError)=>(nativeContext,options)=>{const nativeAnalyserNode=nativeContext.createAnalyser();if(assignNativeAudioNodeOptions(nativeAnalyserNode,options),!(options.maxDecibels>options.minDecibels))throw createIndexSizeError();return assignNativeAudioNodeOption(nativeAnalyserNode,options,"fftSize"),assignNativeAudioNodeOption(nativeAnalyserNode,options,"maxDecibels"),assignNativeAudioNodeOption(nativeAnalyserNode,options,"minDecibels"),assignNativeAudioNodeOption(nativeAnalyserNode,options,"smoothingTimeConstant"),cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport,()=>testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode))||(nativeAnalyserNode=>{nativeAnalyserNode.getFloatTimeDomainData=array=>{const byteTimeDomainData=new Uint8Array(array.length);nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);const length=Math.max(byteTimeDomainData.length,nativeAnalyserNode.fftSize);for(let i=0;i<length;i+=1)array[i]=.0078125*(byteTimeDomainData[i]-128);return array}})(nativeAnalyserNode),nativeAnalyserNode})(cacheTestResult,createIndexSizeError),getAudioNodeRenderer=(getAudioNodeConnections=>audioNode=>{const audioNodeConnections=getAudioNodeConnections(audioNode);if(null===audioNodeConnections.renderer)throw new Error("Missing the renderer of the given AudioNode in the audio graph.");return audioNodeConnections.renderer})(getAudioNodeConnections),renderInputsOfAudioNode=((getAudioNodeConnections,getAudioNodeRenderer,isPartOfACycle)=>async(audioNode,nativeOfflineAudioContext,nativeAudioNode)=>{const audioNodeConnections=getAudioNodeConnections(audioNode);await Promise.all(audioNodeConnections.activeInputs.map((connections,input)=>Array.from(connections).map(async([source,output])=>{const audioNodeRenderer=getAudioNodeRenderer(source),renderedNativeAudioNode=await audioNodeRenderer.render(source,nativeOfflineAudioContext),destination=audioNode.context.destination;isPartOfACycle(source)||audioNode===destination&&isPartOfACycle(audioNode)||renderedNativeAudioNode.connect(nativeAudioNode,output,input)})).reduce((allRenderingPromises,renderingPromises)=>[...allRenderingPromises,...renderingPromises],[]))})(getAudioNodeConnections,getAudioNodeRenderer,isPartOfACycle),createAnalyserNodeRenderer=((createNativeAnalyserNode,getNativeAudioNode,renderInputsOfAudioNode)=>()=>{const renderedNativeAnalyserNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeAnalyserNode=renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeAnalyserNode?Promise.resolve(renderedNativeAnalyserNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeAnalyserNode=getNativeAudioNode(proxy);if(!isOwnedByContext(nativeAnalyserNode,nativeOfflineAudioContext)){const options={channelCount:nativeAnalyserNode.channelCount,channelCountMode:nativeAnalyserNode.channelCountMode,channelInterpretation:nativeAnalyserNode.channelInterpretation,fftSize:nativeAnalyserNode.fftSize,maxDecibels:nativeAnalyserNode.maxDecibels,minDecibels:nativeAnalyserNode.minDecibels,smoothingTimeConstant:nativeAnalyserNode.smoothingTimeConstant};nativeAnalyserNode=createNativeAnalyserNode(nativeOfflineAudioContext,options)}return renderedNativeAnalyserNodes.set(nativeOfflineAudioContext,nativeAnalyserNode),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeAnalyserNode),nativeAnalyserNode})(proxy,nativeOfflineAudioContext)}}})(createNativeAnalyserNode,getNativeAudioNode,renderInputsOfAudioNode),getNativeContext=(contextStore=CONTEXT_STORE,context=>{const nativeContext=contextStore.get(context);if(void 0===nativeContext)throw createInvalidStateError();return nativeContext});var contextStore;const nativeOfflineAudioContextConstructor=(window=>null===window?null:window.hasOwnProperty("OfflineAudioContext")?window.OfflineAudioContext:window.hasOwnProperty("webkitOfflineAudioContext")?window.webkitOfflineAudioContext:null)(module_window),isNativeOfflineAudioContext=(nativeOfflineAudioContextConstructor=>anything=>null!==nativeOfflineAudioContextConstructor&&anything instanceof nativeOfflineAudioContextConstructor)(nativeOfflineAudioContextConstructor),audioParamAudioNodeStore=new WeakMap,eventTargetConstructor=(wrapEventListener=>class EventTarget{constructor(_nativeEventTarget){this._nativeEventTarget=_nativeEventTarget,this._listeners=new WeakMap}addEventListener(type,listener,options){if(null!==listener){let wrappedEventListener=this._listeners.get(listener);void 0===wrappedEventListener&&(wrappedEventListener=wrapEventListener(this,listener),"function"==typeof listener&&this._listeners.set(listener,wrappedEventListener)),this._nativeEventTarget.addEventListener(type,wrappedEventListener,options)}}dispatchEvent(event){return this._nativeEventTarget.dispatchEvent(event)}removeEventListener(type,listener,options){const wrappedEventListener=null===listener?void 0:this._listeners.get(listener);this._nativeEventTarget.removeEventListener(type,void 0===wrappedEventListener?null:wrappedEventListener,options)}})(wrapEventListener),nativeAudioContextConstructor=(window=>null===window?null:window.hasOwnProperty("AudioContext")?window.AudioContext:window.hasOwnProperty("webkitAudioContext")?window.webkitAudioContext:null)(module_window),isNativeAudioContext=(nativeAudioContextConstructor=>anything=>null!==nativeAudioContextConstructor&&anything instanceof nativeAudioContextConstructor)(nativeAudioContextConstructor),module_isNativeAudioNode=(window=>anything=>null!==window&&"function"==typeof window.AudioNode&&anything instanceof window.AudioNode)(module_window),isNativeAudioParam=(window=>anything=>null!==window&&"function"==typeof window.AudioParam&&anything instanceof window.AudioParam)(module_window),nativeAudioWorkletNodeConstructor=(window=>null===window?null:window.hasOwnProperty("AudioWorkletNode")?window.AudioWorkletNode:null)(module_window),audioNodeConstructor=((addAudioNodeConnections,addConnectionToAudioNode,cacheTestResult,createIncrementCycleCounter,createIndexSizeError,createInvalidAccessError,createNotSupportedError,decrementCycleCounter,detectCycles,eventTargetConstructor,getNativeContext,isNativeAudioContext,isNativeAudioNode,isNativeAudioParam,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor)=>class AudioNode extends eventTargetConstructor{constructor(context,isActive,nativeAudioNode,audioNodeRenderer){super(nativeAudioNode),this._context=context,this._nativeAudioNode=nativeAudioNode;const nativeContext=getNativeContext(context);isNativeAudioContext(nativeContext)&&!0!==cacheTestResult(testAudioNodeDisconnectMethodSupport,()=>testAudioNodeDisconnectMethodSupport(nativeContext,nativeAudioWorkletNodeConstructor))&&wrapAudioNodeDisconnectMethod(nativeAudioNode),AUDIO_NODE_STORE.set(this,nativeAudioNode),EVENT_LISTENERS.set(this,new Set),"closed"!==context.state&&isActive&&setInternalStateToActive(this),addAudioNodeConnections(this,audioNodeRenderer,nativeAudioNode)}get channelCount(){return this._nativeAudioNode.channelCount}set channelCount(value){this._nativeAudioNode.channelCount=value}get channelCountMode(){return this._nativeAudioNode.channelCountMode}set channelCountMode(value){this._nativeAudioNode.channelCountMode=value}get channelInterpretation(){return this._nativeAudioNode.channelInterpretation}set channelInterpretation(value){this._nativeAudioNode.channelInterpretation=value}get context(){return this._context}get numberOfInputs(){return this._nativeAudioNode.numberOfInputs}get numberOfOutputs(){return this._nativeAudioNode.numberOfOutputs}connect(destination,output=0,input=0){if(output<0||output>=this._nativeAudioNode.numberOfOutputs)throw createIndexSizeError();const nativeContext=getNativeContext(this._context),isOffline=isNativeOfflineAudioContext(nativeContext);if(isNativeAudioNode(destination)||isNativeAudioParam(destination))throw createInvalidAccessError();if(isAudioNode(destination)){const nativeDestinationAudioNode=getNativeAudioNode(destination);try{const connection=connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode,nativeDestinationAudioNode,output,input),isPassive=isPassiveAudioNode(this);(isOffline||isPassive)&&this._nativeAudioNode.disconnect(...connection),"closed"!==this.context.state&&!isPassive&&isPassiveAudioNode(destination)&&setInternalStateToActive(destination)}catch(err){if(12===err.code)throw createInvalidAccessError();throw err}if(addConnectionToAudioNode(this,destination,output,input,isOffline)){const cycles=detectCycles([this],destination);visitEachAudioNodeOnce(cycles,createIncrementCycleCounter(isOffline))}return destination}const nativeAudioParam=getNativeAudioParam(destination);if("playbackRate"===nativeAudioParam.name&&1024===nativeAudioParam.maxValue)throw createNotSupportedError();try{this._nativeAudioNode.connect(nativeAudioParam,output),(isOffline||isPassiveAudioNode(this))&&this._nativeAudioNode.disconnect(nativeAudioParam,output)}catch(err){if(12===err.code)throw createInvalidAccessError();throw err}if(addConnectionToAudioParamOfAudioContext(this,destination,output,isOffline)){const cycles=detectCycles([this],destination);visitEachAudioNodeOnce(cycles,createIncrementCycleCounter(isOffline))}}disconnect(destinationOrOutput,output,input){let destinations;const nativeContext=getNativeContext(this._context),isOffline=isNativeOfflineAudioContext(nativeContext);if(void 0===destinationOrOutput)destinations=((source,isOffline)=>{const audioNodeConnectionsOfSource=getAudioNodeConnections(source),destinations=[];for(const outputConnection of audioNodeConnectionsOfSource.outputs)isAudioNodeOutputConnection(outputConnection)?deleteInputsOfAudioNode(source,isOffline,...outputConnection):deleteInputsOfAudioParam(source,isOffline,...outputConnection),destinations.push(outputConnection[0]);return audioNodeConnectionsOfSource.outputs.clear(),destinations})(this,isOffline);else if("number"==typeof destinationOrOutput){if(destinationOrOutput<0||destinationOrOutput>=this.numberOfOutputs)throw createIndexSizeError();destinations=((source,isOffline,output)=>{const audioNodeConnectionsOfSource=getAudioNodeConnections(source),destinations=[];for(const outputConnection of audioNodeConnectionsOfSource.outputs)outputConnection[1]===output&&(isAudioNodeOutputConnection(outputConnection)?deleteInputsOfAudioNode(source,isOffline,...outputConnection):deleteInputsOfAudioParam(source,isOffline,...outputConnection),destinations.push(outputConnection[0]),audioNodeConnectionsOfSource.outputs.delete(outputConnection));return destinations})(this,isOffline,destinationOrOutput)}else{if(void 0!==output&&(output<0||output>=this.numberOfOutputs))throw createIndexSizeError();if(isAudioNode(destinationOrOutput)&&void 0!==input&&(input<0||input>=destinationOrOutput.numberOfInputs))throw createIndexSizeError();if(destinations=((source,isOffline,destination,output,input)=>{const audioNodeConnectionsOfSource=getAudioNodeConnections(source);return Array.from(audioNodeConnectionsOfSource.outputs).filter(outputConnection=>!(outputConnection[0]!==destination||void 0!==output&&outputConnection[1]!==output||void 0!==input&&outputConnection[2]!==input)).map(outputConnection=>(isAudioNodeOutputConnection(outputConnection)?deleteInputsOfAudioNode(source,isOffline,...outputConnection):deleteInputsOfAudioParam(source,isOffline,...outputConnection),audioNodeConnectionsOfSource.outputs.delete(outputConnection),outputConnection[0]))})(this,isOffline,destinationOrOutput,output,input),0===destinations.length)throw createInvalidAccessError()}for(const destination of destinations){const cycles=detectCycles([this],destination);visitEachAudioNodeOnce(cycles,decrementCycleCounter)}}})((audioNodeConnectionsStore=AUDIO_NODE_CONNECTIONS_STORE,(audioNode,audioNodeRenderer,nativeAudioNode)=>{const activeInputs=[];for(let i=0;i<nativeAudioNode.numberOfInputs;i+=1)activeInputs.push(new Set);audioNodeConnectionsStore.set(audioNode,{activeInputs,outputs:new Set,passiveInputs:new WeakMap,renderer:audioNodeRenderer})}),((addActiveInputConnectionToAudioNode,addPassiveInputConnectionToAudioNode,connectNativeAudioNodeToNativeAudioNode,deleteActiveInputConnectionToAudioNode,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getAudioNodeTailTime,getEventListenersOfAudioNode,getNativeAudioNode,insertElementInSet,isActiveAudioNode,isPartOfACycle,isPassiveAudioNode)=>{const tailTimeTimeoutIds=new WeakMap;return(source,destination,output,input,isOffline)=>{const{activeInputs,passiveInputs}=getAudioNodeConnections(destination),{outputs}=getAudioNodeConnections(source),eventListeners=getEventListenersOfAudioNode(source),eventListener=isActive=>{const nativeDestinationAudioNode=getNativeAudioNode(destination),nativeSourceAudioNode=getNativeAudioNode(source);if(isActive){const partialConnection=deletePassiveInputConnectionToAudioNode(passiveInputs,source,output,input);addActiveInputConnectionToAudioNode(activeInputs,source,partialConnection,!1),isOffline||isPartOfACycle(source)||connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode,nativeDestinationAudioNode,output,input),isPassiveAudioNode(destination)&&setInternalStateToActive(destination)}else{const partialConnection=deleteActiveInputConnectionToAudioNode(activeInputs,source,output,input);addPassiveInputConnectionToAudioNode(passiveInputs,input,partialConnection,!1),isOffline||isPartOfACycle(source)||disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode,nativeDestinationAudioNode,output,input);const tailTime=getAudioNodeTailTime(destination);if(0===tailTime)isActiveAudioNode(destination)&&setInternalStateToPassiveWhenNecessary(destination,activeInputs);else{const tailTimeTimeoutId=tailTimeTimeoutIds.get(destination);void 0!==tailTimeTimeoutId&&clearTimeout(tailTimeTimeoutId),tailTimeTimeoutIds.set(destination,setTimeout(()=>{isActiveAudioNode(destination)&&setInternalStateToPassiveWhenNecessary(destination,activeInputs)},1e3*tailTime))}}};return!!insertElementInSet(outputs,[destination,output,input],outputConnection=>outputConnection[0]===destination&&outputConnection[1]===output&&outputConnection[2]===input,!0)&&(eventListeners.add(eventListener),isActiveAudioNode(source)?addActiveInputConnectionToAudioNode(activeInputs,source,[output,input,eventListener],!0):addPassiveInputConnectionToAudioNode(passiveInputs,input,[source,output,eventListener],!0),!0)}})(addActiveInputConnectionToAudioNode,addPassiveInputConnectionToAudioNode,connectNativeAudioNodeToNativeAudioNode,deleteActiveInputConnectionToAudioNode,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getAudioNodeTailTime,getEventListenersOfAudioNode,getNativeAudioNode,insertElementInSet,isActiveAudioNode,isPartOfACycle,isPassiveAudioNode),cacheTestResult,((cycleCounters,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,isActiveAudioNode)=>isOffline=>(audioNode,count)=>{const cycleCounter=cycleCounters.get(audioNode);if(void 0===cycleCounter){if(!isOffline&&isActiveAudioNode(audioNode)){const nativeSourceAudioNode=getNativeAudioNode(audioNode),{outputs}=getAudioNodeConnections(audioNode);for(const output of outputs)if(isAudioNodeOutputConnection(output)){const nativeDestinationAudioNode=getNativeAudioNode(output[0]);disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode,nativeDestinationAudioNode,output[1],output[2])}else{const nativeDestinationAudioParam=getNativeAudioParam(output[0]);nativeSourceAudioNode.disconnect(nativeDestinationAudioParam,output[1])}}cycleCounters.set(audioNode,count)}else cycleCounters.set(audioNode,cycleCounter+count)})(CYCLE_COUNTERS,disconnectNativeAudioNodeFromNativeAudioNode,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,isActiveAudioNode),createIndexSizeError,createInvalidAccessError,createNotSupportedError,((connectNativeAudioNodeToNativeAudioNode,cycleCounters,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,getNativeContext,isActiveAudioNode,isNativeOfflineAudioContext)=>(audioNode,count)=>{const cycleCounter=cycleCounters.get(audioNode);if(void 0===cycleCounter)throw new Error("Missing the expected cycle count.");const nativeContext=getNativeContext(audioNode.context),isOffline=isNativeOfflineAudioContext(nativeContext);if(cycleCounter===count){if(cycleCounters.delete(audioNode),!isOffline&&isActiveAudioNode(audioNode)){const nativeSourceAudioNode=getNativeAudioNode(audioNode),{outputs}=getAudioNodeConnections(audioNode);for(const output of outputs)if(isAudioNodeOutputConnection(output)){const nativeDestinationAudioNode=getNativeAudioNode(output[0]);connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode,nativeDestinationAudioNode,output[1],output[2])}else{const nativeDestinationAudioParam=getNativeAudioParam(output[0]);nativeSourceAudioNode.connect(nativeDestinationAudioParam,output[1])}}}else cycleCounters.set(audioNode,cycleCounter-count)})(connectNativeAudioNodeToNativeAudioNode,CYCLE_COUNTERS,getAudioNodeConnections,getNativeAudioNode,getNativeAudioParam,getNativeContext,isActiveAudioNode,isNativeOfflineAudioContext),((audioParamAudioNodeStore,getAudioNodeConnections,getValueForKey)=>function detectCycles(chain,nextLink){const audioNode=isAudioNode(nextLink)?nextLink:getValueForKey(audioParamAudioNodeStore,nextLink);if((audioNode=>"delayTime"in audioNode)(audioNode))return[];if(chain[0]===audioNode)return[chain];if(chain.includes(audioNode))return[];const{outputs}=getAudioNodeConnections(audioNode);return Array.from(outputs).map(outputConnection=>detectCycles([...chain,audioNode],outputConnection[0])).reduce((mergedCycles,nestedCycles)=>mergedCycles.concat(nestedCycles),[])})(audioParamAudioNodeStore,getAudioNodeConnections,getValueForKey),eventTargetConstructor,getNativeContext,isNativeAudioContext,module_isNativeAudioNode,isNativeAudioParam,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor);var audioNodeConnectionsStore;const analyserNodeConstructor=((audionNodeConstructor,createAnalyserNodeRenderer,createIndexSizeError,createNativeAnalyserNode,getNativeContext,isNativeOfflineAudioContext)=>class AnalyserNode extends audionNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...DEFAULT_OPTIONS,...options},nativeAnalyserNode=createNativeAnalyserNode(nativeContext,mergedOptions);super(context,!1,nativeAnalyserNode,isNativeOfflineAudioContext(nativeContext)?createAnalyserNodeRenderer():null),this._nativeAnalyserNode=nativeAnalyserNode}get fftSize(){return this._nativeAnalyserNode.fftSize}set fftSize(value){this._nativeAnalyserNode.fftSize=value}get frequencyBinCount(){return this._nativeAnalyserNode.frequencyBinCount}get maxDecibels(){return this._nativeAnalyserNode.maxDecibels}set maxDecibels(value){const maxDecibels=this._nativeAnalyserNode.maxDecibels;if(this._nativeAnalyserNode.maxDecibels=value,!(value>this._nativeAnalyserNode.minDecibels))throw this._nativeAnalyserNode.maxDecibels=maxDecibels,createIndexSizeError()}get minDecibels(){return this._nativeAnalyserNode.minDecibels}set minDecibels(value){const minDecibels=this._nativeAnalyserNode.minDecibels;if(this._nativeAnalyserNode.minDecibels=value,!(this._nativeAnalyserNode.maxDecibels>value))throw this._nativeAnalyserNode.minDecibels=minDecibels,createIndexSizeError()}get smoothingTimeConstant(){return this._nativeAnalyserNode.smoothingTimeConstant}set smoothingTimeConstant(value){this._nativeAnalyserNode.smoothingTimeConstant=value}getByteFrequencyData(array){this._nativeAnalyserNode.getByteFrequencyData(array)}getByteTimeDomainData(array){this._nativeAnalyserNode.getByteTimeDomainData(array)}getFloatFrequencyData(array){this._nativeAnalyserNode.getFloatFrequencyData(array)}getFloatTimeDomainData(array){this._nativeAnalyserNode.getFloatTimeDomainData(array)}})(audioNodeConstructor,createAnalyserNodeRenderer,createIndexSizeError,createNativeAnalyserNode,getNativeContext,isNativeOfflineAudioContext),audioBufferStore=new WeakSet,nativeAudioBufferConstructor=(window=>null===window?null:window.hasOwnProperty("AudioBuffer")?window.AudioBuffer:null)(module_window),convertNumberToUnsignedLong=(unit32Array=new Uint32Array(1),value=>(unit32Array[0]=value,unit32Array[0]));var unit32Array;const wrapAudioBufferCopyChannelMethods=((convertNumberToUnsignedLong,createIndexSizeError)=>audioBuffer=>{audioBuffer.copyFromChannel=(destination,channelNumberAsNumber,bufferOffsetAsNumber=0)=>{const bufferOffset=convertNumberToUnsignedLong(bufferOffsetAsNumber),channelNumber=convertNumberToUnsignedLong(channelNumberAsNumber);if(channelNumber>=audioBuffer.numberOfChannels)throw createIndexSizeError();const audioBufferLength=audioBuffer.length,channelData=audioBuffer.getChannelData(channelNumber),destinationLength=destination.length;for(let i=bufferOffset<0?-bufferOffset:0;i+bufferOffset<audioBufferLength&&i<destinationLength;i+=1)destination[i]=channelData[i+bufferOffset]},audioBuffer.copyToChannel=(source,channelNumberAsNumber,bufferOffsetAsNumber=0)=>{const bufferOffset=convertNumberToUnsignedLong(bufferOffsetAsNumber),channelNumber=convertNumberToUnsignedLong(channelNumberAsNumber);if(channelNumber>=audioBuffer.numberOfChannels)throw createIndexSizeError();const audioBufferLength=audioBuffer.length,channelData=audioBuffer.getChannelData(channelNumber),sourceLength=source.length;for(let i=bufferOffset<0?-bufferOffset:0;i+bufferOffset<audioBufferLength&&i<sourceLength;i+=1)channelData[i+bufferOffset]=source[i]}})(convertNumberToUnsignedLong,createIndexSizeError),wrapAudioBufferCopyChannelMethodsOutOfBounds=(convertNumberToUnsignedLong=>audioBuffer=>{audioBuffer.copyFromChannel=(copyFromChannel=>(destination,channelNumberAsNumber,bufferOffsetAsNumber=0)=>{const bufferOffset=convertNumberToUnsignedLong(bufferOffsetAsNumber),channelNumber=convertNumberToUnsignedLong(channelNumberAsNumber);if(bufferOffset<audioBuffer.length)return copyFromChannel.call(audioBuffer,destination,channelNumber,bufferOffset)})(audioBuffer.copyFromChannel),audioBuffer.copyToChannel=(copyToChannel=>(source,channelNumberAsNumber,bufferOffsetAsNumber=0)=>{const bufferOffset=convertNumberToUnsignedLong(bufferOffsetAsNumber),channelNumber=convertNumberToUnsignedLong(channelNumberAsNumber);if(bufferOffset<audioBuffer.length)return copyToChannel.call(audioBuffer,source,channelNumber,bufferOffset)})(audioBuffer.copyToChannel)})(convertNumberToUnsignedLong),audioBufferConstructor=((audioBufferStore,cacheTestResult,createNotSupportedError,nativeAudioBufferConstructor,nativeOfflineAudioContextConstructor,testNativeAudioBufferConstructorSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds)=>{let nativeOfflineAudioContext=null;return class AudioBuffer{constructor(options){if(null===nativeOfflineAudioContextConstructor)throw new Error("Missing the native OfflineAudioContext constructor.");const{length,numberOfChannels,sampleRate}={...audio_buffer_constructor_DEFAULT_OPTIONS,...options};null===nativeOfflineAudioContext&&(nativeOfflineAudioContext=new nativeOfflineAudioContextConstructor(1,1,44100));const audioBuffer=null!==nativeAudioBufferConstructor&&cacheTestResult(testNativeAudioBufferConstructorSupport,testNativeAudioBufferConstructorSupport)?new nativeAudioBufferConstructor({length,numberOfChannels,sampleRate}):nativeOfflineAudioContext.createBuffer(numberOfChannels,length,sampleRate);if(0===audioBuffer.numberOfChannels)throw createNotSupportedError();return"function"!=typeof audioBuffer.copyFromChannel?(wrapAudioBufferCopyChannelMethods(audioBuffer),wrapAudioBufferGetChannelDataMethod(audioBuffer)):cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport,()=>testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))||wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer),audioBufferStore.add(audioBuffer),audioBuffer}static[Symbol.hasInstance](instance){return null!==instance&&"object"==typeof instance&&Object.getPrototypeOf(instance)===AudioBuffer.prototype||audioBufferStore.has(instance)}}})(audioBufferStore,cacheTestResult,createNotSupportedError,nativeAudioBufferConstructor,nativeOfflineAudioContextConstructor,(nativeAudioBufferConstructor=>()=>{if(null===nativeAudioBufferConstructor)return!1;try{new nativeAudioBufferConstructor({length:1,sampleRate:44100})}catch{return!1}return!0})(nativeAudioBufferConstructor),wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds),addSilentConnection=(createNativeGainNode=>(nativeContext,nativeAudioScheduledSourceNode)=>{const nativeGainNode=createNativeGainNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);const disconnect=()=>{nativeAudioScheduledSourceNode.removeEventListener("ended",disconnect),nativeAudioScheduledSourceNode.disconnect(nativeGainNode),nativeGainNode.disconnect()};nativeAudioScheduledSourceNode.addEventListener("ended",disconnect)})(createNativeGainNode),renderInputsOfAudioParam=((getAudioNodeRenderer,getAudioParamConnections,isPartOfACycle)=>async(audioParam,nativeOfflineAudioContext,nativeAudioParam)=>{const audioParamConnections=getAudioParamConnections(audioParam);await Promise.all(Array.from(audioParamConnections.activeInputs).map(async([source,output])=>{const audioNodeRenderer=getAudioNodeRenderer(source),renderedNativeAudioNode=await audioNodeRenderer.render(source,nativeOfflineAudioContext);isPartOfACycle(source)||renderedNativeAudioNode.connect(nativeAudioParam,output)}))})(getAudioNodeRenderer,getAudioParamConnections,isPartOfACycle),connectAudioParam=(renderInputsOfAudioParam=>(nativeOfflineAudioContext,audioParam,nativeAudioParam)=>renderInputsOfAudioParam(audioParam,nativeOfflineAudioContext,nativeAudioParam))(renderInputsOfAudioParam),createNativeAudioBufferSourceNode=((addSilentConnection,cacheTestResult,testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,testAudioBufferSourceNodeStartMethodOffsetClampingSupport,testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioBufferSourceNodeStartMethodOffsetClampling,wrapAudioBufferSourceNodeStopMethodNullifiedBuffer,wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls)=>(nativeContext,options)=>{const nativeAudioBufferSourceNode=nativeContext.createBufferSource();return assignNativeAudioNodeOptions(nativeAudioBufferSourceNode,options),assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode,options,"playbackRate"),assignNativeAudioNodeOption(nativeAudioBufferSourceNode,options,"buffer"),assignNativeAudioNodeOption(nativeAudioBufferSourceNode,options,"loop"),assignNativeAudioNodeOption(nativeAudioBufferSourceNode,options,"loopEnd"),assignNativeAudioNodeOption(nativeAudioBufferSourceNode,options,"loopStart"),cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,()=>testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext))||(nativeAudioBufferSourceNode=>{nativeAudioBufferSourceNode.start=(start=>{let isScheduled=!1;return(when=0,offset=0,duration)=>{if(isScheduled)throw createInvalidStateError();start.call(nativeAudioBufferSourceNode,when,offset,duration),isScheduled=!0}})(nativeAudioBufferSourceNode.start)})(nativeAudioBufferSourceNode),cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport,()=>testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext))||wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode),cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,()=>testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext))||wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode,nativeContext),cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,()=>testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode),cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,()=>testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))||wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode,nativeContext),cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,()=>testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode),addSilentConnection(nativeContext,nativeAudioBufferSourceNode),nativeAudioBufferSourceNode})(addSilentConnection,cacheTestResult,nativeContext=>{const nativeAudioBufferSourceNode=nativeContext.createBufferSource();nativeAudioBufferSourceNode.start();try{nativeAudioBufferSourceNode.start()}catch{return!0}return!1},nativeContext=>{const nativeAudioBufferSourceNode=nativeContext.createBufferSource(),nativeAudioBuffer=nativeContext.createBuffer(1,1,44100);nativeAudioBufferSourceNode.buffer=nativeAudioBuffer;try{nativeAudioBufferSourceNode.start(0,1)}catch{return!1}return!0},nativeContext=>{const nativeAudioBufferSourceNode=nativeContext.createBufferSource();nativeAudioBufferSourceNode.start();try{nativeAudioBufferSourceNode.stop()}catch{return!1}return!0},testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,nativeAudioBufferSourceNode=>{var start;nativeAudioBufferSourceNode.start=(start=nativeAudioBufferSourceNode.start,(when=0,offset=0,duration)=>{const buffer=nativeAudioBufferSourceNode.buffer,clampedOffset=null===buffer?offset:Math.min(buffer.duration,offset);null!==buffer&&clampedOffset>buffer.duration-.5/nativeAudioBufferSourceNode.context.sampleRate?start.call(nativeAudioBufferSourceNode,when,0,0):start.call(nativeAudioBufferSourceNode,when,clampedOffset,duration)})},(overwriteAccessors=>(nativeAudioBufferSourceNode,nativeContext)=>{const nullifiedBuffer=nativeContext.createBuffer(1,1,44100);null===nativeAudioBufferSourceNode.buffer&&(nativeAudioBufferSourceNode.buffer=nullifiedBuffer),overwriteAccessors(nativeAudioBufferSourceNode,"buffer",get=>()=>{const value=get.call(nativeAudioBufferSourceNode);return value===nullifiedBuffer?null:value},set=>value=>set.call(nativeAudioBufferSourceNode,null===value?nullifiedBuffer:value))})(overwriteAccessors),wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls),renderAutomation=((getAudioParamRenderer,renderInputsOfAudioParam)=>(nativeOfflineAudioContext,audioParam,nativeAudioParam)=>(getAudioParamRenderer(audioParam).replay(nativeAudioParam),renderInputsOfAudioParam(audioParam,nativeOfflineAudioContext,nativeAudioParam)))((getAudioParamConnections=>audioParam=>{const audioParamConnections=getAudioParamConnections(audioParam);if(null===audioParamConnections.renderer)throw new Error("Missing the renderer of the given AudioParam in the audio graph.");return audioParamConnections.renderer})(getAudioParamConnections),renderInputsOfAudioParam),createAudioBufferSourceNodeRenderer=((connectAudioParam,createNativeAudioBufferSourceNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode)=>()=>{const renderedNativeAudioBufferSourceNodes=new WeakMap;let start=null,stop=null;return{set start(value){start=value},set stop(value){stop=value},render(proxy,nativeOfflineAudioContext){const renderedNativeAudioBufferSourceNode=renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeAudioBufferSourceNode?Promise.resolve(renderedNativeAudioBufferSourceNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeAudioBufferSourceNode=getNativeAudioNode(proxy);const nativeAudioBufferSourceNodeIsOwnedByContext=isOwnedByContext(nativeAudioBufferSourceNode,nativeOfflineAudioContext);if(!nativeAudioBufferSourceNodeIsOwnedByContext){const options={buffer:nativeAudioBufferSourceNode.buffer,channelCount:nativeAudioBufferSourceNode.channelCount,channelCountMode:nativeAudioBufferSourceNode.channelCountMode,channelInterpretation:nativeAudioBufferSourceNode.channelInterpretation,loop:nativeAudioBufferSourceNode.loop,loopEnd:nativeAudioBufferSourceNode.loopEnd,loopStart:nativeAudioBufferSourceNode.loopStart,playbackRate:nativeAudioBufferSourceNode.playbackRate.value};nativeAudioBufferSourceNode=createNativeAudioBufferSourceNode(nativeOfflineAudioContext,options),null!==start&&nativeAudioBufferSourceNode.start(...start),null!==stop&&nativeAudioBufferSourceNode.stop(stop)}return renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext,nativeAudioBufferSourceNode),nativeAudioBufferSourceNodeIsOwnedByContext?await connectAudioParam(nativeOfflineAudioContext,proxy.playbackRate,nativeAudioBufferSourceNode.playbackRate):await renderAutomation(nativeOfflineAudioContext,proxy.playbackRate,nativeAudioBufferSourceNode.playbackRate),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeAudioBufferSourceNode),nativeAudioBufferSourceNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeAudioBufferSourceNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),createAudioParam=((addAudioParamConnections,audioParamAudioNodeStore,audioParamStore,createAudioParamRenderer,createCancelAndHoldAutomationEvent,createCancelScheduledValuesAutomationEvent,createExponentialRampToValueAutomationEvent,createLinearRampToValueAutomationEvent,createSetTargetAutomationEvent,createSetValueAutomationEvent,createSetValueCurveAutomationEvent,nativeAudioContextConstructor,setValueAtTimeUntilPossible)=>(audioNode,isAudioParamOfOfflineAudioContext,nativeAudioParam,maxValue=null,minValue=null)=>{const automationEventList=new bundle.AutomationEventList(nativeAudioParam.defaultValue),audioParamRenderer=isAudioParamOfOfflineAudioContext?createAudioParamRenderer(automationEventList):null,audioParam={get defaultValue(){return nativeAudioParam.defaultValue},get maxValue(){return null===maxValue?nativeAudioParam.maxValue:maxValue},get minValue(){return null===minValue?nativeAudioParam.minValue:minValue},get value(){return nativeAudioParam.value},set value(value){nativeAudioParam.value=value,audioParam.setValueAtTime(value,audioNode.context.currentTime)},cancelAndHoldAtTime(cancelTime){if("function"==typeof nativeAudioParam.cancelAndHoldAtTime)null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime)),nativeAudioParam.cancelAndHoldAtTime(cancelTime);else{const previousLastEvent=Array.from(automationEventList).pop();null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));const currentLastEvent=Array.from(automationEventList).pop();nativeAudioParam.cancelScheduledValues(cancelTime),previousLastEvent!==currentLastEvent&&void 0!==currentLastEvent&&("exponentialRampToValue"===currentLastEvent.type?nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value,currentLastEvent.endTime):"linearRampToValue"===currentLastEvent.type?nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value,currentLastEvent.endTime):"setValue"===currentLastEvent.type?nativeAudioParam.setValueAtTime(currentLastEvent.value,currentLastEvent.startTime):"setValueCurve"===currentLastEvent.type&&nativeAudioParam.setValueCurveAtTime(currentLastEvent.values,currentLastEvent.startTime,currentLastEvent.duration))}return audioParam},cancelScheduledValues:cancelTime=>(null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime)),nativeAudioParam.cancelScheduledValues(cancelTime),audioParam),exponentialRampToValueAtTime(value,endTime){if(0===value)throw new RangeError;if(!Number.isFinite(endTime)||endTime<0)throw new RangeError;return null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createExponentialRampToValueAutomationEvent(value,endTime)),nativeAudioParam.exponentialRampToValueAtTime(value,endTime),audioParam},linearRampToValueAtTime:(value,endTime)=>(null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createLinearRampToValueAutomationEvent(value,endTime)),nativeAudioParam.linearRampToValueAtTime(value,endTime),audioParam),setTargetAtTime:(target,startTime,timeConstant)=>(null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createSetTargetAutomationEvent(target,startTime,timeConstant)),nativeAudioParam.setTargetAtTime(target,startTime,timeConstant),audioParam),setValueAtTime:(value,startTime)=>(null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createSetValueAutomationEvent(value,startTime)),nativeAudioParam.setValueAtTime(value,startTime),audioParam),setValueCurveAtTime(values,startTime,duration){const convertedValues=values instanceof Float32Array?values:new Float32Array(values);if(null!==nativeAudioContextConstructor&&"webkitAudioContext"===nativeAudioContextConstructor.name){const endTime=startTime+duration,sampleRate=audioNode.context.sampleRate,firstSample=Math.ceil(startTime*sampleRate),lastSample=Math.floor(endTime*sampleRate),numberOfInterpolatedValues=lastSample-firstSample,interpolatedValues=new Float32Array(numberOfInterpolatedValues);for(let i=0;i<numberOfInterpolatedValues;i+=1){const theoreticIndex=(convertedValues.length-1)/duration*((firstSample+i)/sampleRate-startTime),lowerIndex=Math.floor(theoreticIndex),upperIndex=Math.ceil(theoreticIndex);interpolatedValues[i]=lowerIndex===upperIndex?convertedValues[lowerIndex]:(1-(theoreticIndex-lowerIndex))*convertedValues[lowerIndex]+(1-(upperIndex-theoreticIndex))*convertedValues[upperIndex]}null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues,startTime,duration)),nativeAudioParam.setValueCurveAtTime(interpolatedValues,startTime,duration);const timeOfLastSample=lastSample/sampleRate;timeOfLastSample<endTime&&setValueAtTimeUntilPossible(audioParam,interpolatedValues[interpolatedValues.length-1],timeOfLastSample),setValueAtTimeUntilPossible(audioParam,convertedValues[convertedValues.length-1],endTime)}else null===audioParamRenderer&&automationEventList.flush(audioNode.context.currentTime),automationEventList.add(createSetValueCurveAutomationEvent(convertedValues,startTime,duration)),nativeAudioParam.setValueCurveAtTime(convertedValues,startTime,duration);return audioParam}};return audioParamStore.set(audioParam,nativeAudioParam),audioParamAudioNodeStore.set(audioParam,audioNode),addAudioParamConnections(audioParam,audioParamRenderer),audioParam})((audioParamConnectionsStore=AUDIO_PARAM_CONNECTIONS_STORE,(audioParam,audioParamRenderer)=>{audioParamConnectionsStore.set(audioParam,{activeInputs:new Set,passiveInputs:new WeakMap,renderer:audioParamRenderer})}),audioParamAudioNodeStore,AUDIO_PARAM_STORE,automationEventList=>({replay(audioParam){for(const automationEvent of automationEventList)if("exponentialRampToValue"===automationEvent.type){const{endTime,value}=automationEvent;audioParam.exponentialRampToValueAtTime(value,endTime)}else if("linearRampToValue"===automationEvent.type){const{endTime,value}=automationEvent;audioParam.linearRampToValueAtTime(value,endTime)}else if("setTarget"===automationEvent.type){const{startTime,target,timeConstant}=automationEvent;audioParam.setTargetAtTime(target,startTime,timeConstant)}else if("setValue"===automationEvent.type){const{startTime,value}=automationEvent;audioParam.setValueAtTime(value,startTime)}else{if("setValueCurve"!==automationEvent.type)throw new Error("Can't apply an unknown automation.");{const{duration,startTime,values}=automationEvent;audioParam.setValueCurveAtTime(values,startTime,duration)}}}}),bundle.createCancelAndHoldAutomationEvent,bundle.createCancelScheduledValuesAutomationEvent,bundle.createExponentialRampToValueAutomationEvent,bundle.createLinearRampToValueAutomationEvent,bundle.createSetTargetAutomationEvent,bundle.createSetValueAutomationEvent,bundle.createSetValueCurveAutomationEvent,nativeAudioContextConstructor,setValueAtTimeUntilPossible);var audioParamConnectionsStore;const audioBufferSourceNodeConstructor=((audioNodeConstructor,createAudioBufferSourceNodeRenderer,createAudioParam,createInvalidStateError,createNativeAudioBufferSourceNode,getNativeContext,isNativeOfflineAudioContext,wrapEventListener)=>class AudioBufferSourceNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...audio_buffer_source_node_constructor_DEFAULT_OPTIONS,...options},nativeAudioBufferSourceNode=createNativeAudioBufferSourceNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext),audioBufferSourceNodeRenderer=isOffline?createAudioBufferSourceNodeRenderer():null;super(context,!1,nativeAudioBufferSourceNode,audioBufferSourceNodeRenderer),this._audioBufferSourceNodeRenderer=audioBufferSourceNodeRenderer,this._isBufferNullified=!1,this._isBufferSet=null!==mergedOptions.buffer,this._nativeAudioBufferSourceNode=nativeAudioBufferSourceNode,this._onended=null,this._playbackRate=createAudioParam(this,isOffline,nativeAudioBufferSourceNode.playbackRate,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT)}get buffer(){return this._isBufferNullified?null:this._nativeAudioBufferSourceNode.buffer}set buffer(value){if(this._nativeAudioBufferSourceNode.buffer=value,null!==value){if(this._isBufferSet)throw createInvalidStateError();this._isBufferSet=!0}}get loop(){return this._nativeAudioBufferSourceNode.loop}set loop(value){this._nativeAudioBufferSourceNode.loop=value}get loopEnd(){return this._nativeAudioBufferSourceNode.loopEnd}set loopEnd(value){this._nativeAudioBufferSourceNode.loopEnd=value}get loopStart(){return this._nativeAudioBufferSourceNode.loopStart}set loopStart(value){this._nativeAudioBufferSourceNode.loopStart=value}get onended(){return this._onended}set onended(value){const wrappedListener="function"==typeof value?wrapEventListener(this,value):null;this._nativeAudioBufferSourceNode.onended=wrappedListener;const nativeOnEnded=this._nativeAudioBufferSourceNode.onended;this._onended=null!==nativeOnEnded&&nativeOnEnded===wrappedListener?value:nativeOnEnded}get playbackRate(){return this._playbackRate}start(when=0,offset=0,duration){if(this._nativeAudioBufferSourceNode.start(when,offset,duration),null!==this._audioBufferSourceNodeRenderer&&(this._audioBufferSourceNodeRenderer.start=void 0===duration?[when,offset]:[when,offset,duration]),"closed"!==this.context.state){setInternalStateToActive(this);const resetInternalStateToPassive=()=>{this._nativeAudioBufferSourceNode.removeEventListener("ended",resetInternalStateToPassive),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeAudioBufferSourceNode.addEventListener("ended",resetInternalStateToPassive)}}stop(when=0){this._nativeAudioBufferSourceNode.stop(when),null!==this._audioBufferSourceNodeRenderer&&(this._audioBufferSourceNodeRenderer.stop=when)}})(audioNodeConstructor,createAudioBufferSourceNodeRenderer,createAudioParam,createInvalidStateError,createNativeAudioBufferSourceNode,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),audioDestinationNodeConstructor=((audioNodeConstructor,createAudioDestinationNodeRenderer,createIndexSizeError,createInvalidStateError,createNativeAudioDestinationNode,getNativeContext,isNativeOfflineAudioContext,renderInputsOfAudioNode)=>class AudioDestinationNode extends audioNodeConstructor{constructor(context,channelCount){const nativeContext=getNativeContext(context),isOffline=isNativeOfflineAudioContext(nativeContext),nativeAudioDestinationNode=createNativeAudioDestinationNode(nativeContext,channelCount,isOffline);super(context,!1,nativeAudioDestinationNode,isOffline?createAudioDestinationNodeRenderer(renderInputsOfAudioNode):null),this._isNodeOfNativeOfflineAudioContext=isOffline,this._nativeAudioDestinationNode=nativeAudioDestinationNode}get channelCount(){return this._nativeAudioDestinationNode.channelCount}set channelCount(value){if(this._isNodeOfNativeOfflineAudioContext)throw createInvalidStateError();if(value>this._nativeAudioDestinationNode.maxChannelCount)throw createIndexSizeError();this._nativeAudioDestinationNode.channelCount=value}get channelCountMode(){return this._nativeAudioDestinationNode.channelCountMode}set channelCountMode(value){if(this._isNodeOfNativeOfflineAudioContext)throw createInvalidStateError();this._nativeAudioDestinationNode.channelCountMode=value}get maxChannelCount(){return this._nativeAudioDestinationNode.maxChannelCount}})(audioNodeConstructor,renderInputsOfAudioNode=>{const renderedNativeAudioDestinationNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeAudioDestinationNode=renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeAudioDestinationNode?Promise.resolve(renderedNativeAudioDestinationNode):(async(proxy,nativeOfflineAudioContext)=>{const nativeAudioDestinationNode=nativeOfflineAudioContext.destination;return renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext,nativeAudioDestinationNode),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeAudioDestinationNode),nativeAudioDestinationNode})(proxy,nativeOfflineAudioContext)}}},createIndexSizeError,createInvalidStateError,((createNativeGainNode,overwriteAccessors)=>(nativeContext,channelCount,isNodeOfNativeOfflineAudioContext)=>{const nativeAudioDestinationNode=nativeContext.destination;if(nativeAudioDestinationNode.channelCount!==channelCount)try{nativeAudioDestinationNode.channelCount=channelCount}catch{}isNodeOfNativeOfflineAudioContext&&"explicit"!==nativeAudioDestinationNode.channelCountMode&&(nativeAudioDestinationNode.channelCountMode="explicit"),0===nativeAudioDestinationNode.maxChannelCount&&Object.defineProperty(nativeAudioDestinationNode,"maxChannelCount",{value:channelCount});const gainNode=createNativeGainNode(nativeContext,{channelCount,channelCountMode:nativeAudioDestinationNode.channelCountMode,channelInterpretation:nativeAudioDestinationNode.channelInterpretation,gain:1});return overwriteAccessors(gainNode,"channelCount",get=>()=>get.call(gainNode),set=>value=>{set.call(gainNode,value);try{nativeAudioDestinationNode.channelCount=value}catch(err){if(value>nativeAudioDestinationNode.maxChannelCount)throw err}}),overwriteAccessors(gainNode,"channelCountMode",get=>()=>get.call(gainNode),set=>value=>{set.call(gainNode,value),nativeAudioDestinationNode.channelCountMode=value}),overwriteAccessors(gainNode,"channelInterpretation",get=>()=>get.call(gainNode),set=>value=>{set.call(gainNode,value),nativeAudioDestinationNode.channelInterpretation=value}),Object.defineProperty(gainNode,"maxChannelCount",{get:()=>nativeAudioDestinationNode.maxChannelCount}),gainNode.connect(nativeAudioDestinationNode),gainNode})(createNativeGainNode,overwriteAccessors),getNativeContext,isNativeOfflineAudioContext,renderInputsOfAudioNode),createBiquadFilterNodeRenderer=((connectAudioParam,createNativeBiquadFilterNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode)=>()=>{const renderedNativeBiquadFilterNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeBiquadFilterNode=renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeBiquadFilterNode?Promise.resolve(renderedNativeBiquadFilterNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeBiquadFilterNode=getNativeAudioNode(proxy);const nativeBiquadFilterNodeIsOwnedByContext=isOwnedByContext(nativeBiquadFilterNode,nativeOfflineAudioContext);if(!nativeBiquadFilterNodeIsOwnedByContext){const options={Q:nativeBiquadFilterNode.Q.value,channelCount:nativeBiquadFilterNode.channelCount,channelCountMode:nativeBiquadFilterNode.channelCountMode,channelInterpretation:nativeBiquadFilterNode.channelInterpretation,detune:nativeBiquadFilterNode.detune.value,frequency:nativeBiquadFilterNode.frequency.value,gain:nativeBiquadFilterNode.gain.value,type:nativeBiquadFilterNode.type};nativeBiquadFilterNode=createNativeBiquadFilterNode(nativeOfflineAudioContext,options)}return renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext,nativeBiquadFilterNode),nativeBiquadFilterNodeIsOwnedByContext?(await connectAudioParam(nativeOfflineAudioContext,proxy.Q,nativeBiquadFilterNode.Q),await connectAudioParam(nativeOfflineAudioContext,proxy.detune,nativeBiquadFilterNode.detune),await connectAudioParam(nativeOfflineAudioContext,proxy.frequency,nativeBiquadFilterNode.frequency),await connectAudioParam(nativeOfflineAudioContext,proxy.gain,nativeBiquadFilterNode.gain)):(await renderAutomation(nativeOfflineAudioContext,proxy.Q,nativeBiquadFilterNode.Q),await renderAutomation(nativeOfflineAudioContext,proxy.detune,nativeBiquadFilterNode.detune),await renderAutomation(nativeOfflineAudioContext,proxy.frequency,nativeBiquadFilterNode.frequency),await renderAutomation(nativeOfflineAudioContext,proxy.gain,nativeBiquadFilterNode.gain)),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeBiquadFilterNode),nativeBiquadFilterNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeBiquadFilterNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),setAudioNodeTailTime=(audioNodeTailTimeStore=>(audioNode,tailTime)=>audioNodeTailTimeStore.set(audioNode,tailTime))(audioNodeTailTimeStore),biquadFilterNodeConstructor=((audioNodeConstructor,createAudioParam,createBiquadFilterNodeRenderer,createInvalidAccessError,createNativeBiquadFilterNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime)=>class BiquadFilterNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...biquad_filter_node_constructor_DEFAULT_OPTIONS,...options},nativeBiquadFilterNode=createNativeBiquadFilterNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext);super(context,!1,nativeBiquadFilterNode,isOffline?createBiquadFilterNodeRenderer():null),this._Q=createAudioParam(this,isOffline,nativeBiquadFilterNode.Q,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._detune=createAudioParam(this,isOffline,nativeBiquadFilterNode.detune,1200*Math.log2(MOST_POSITIVE_SINGLE_FLOAT),-1200*Math.log2(MOST_POSITIVE_SINGLE_FLOAT)),this._frequency=createAudioParam(this,isOffline,nativeBiquadFilterNode.frequency,context.sampleRate/2,0),this._gain=createAudioParam(this,isOffline,nativeBiquadFilterNode.gain,40*Math.log10(MOST_POSITIVE_SINGLE_FLOAT),MOST_NEGATIVE_SINGLE_FLOAT),this._nativeBiquadFilterNode=nativeBiquadFilterNode,setAudioNodeTailTime(this,1)}get detune(){return this._detune}get frequency(){return this._frequency}get gain(){return this._gain}get Q(){return this._Q}get type(){return this._nativeBiquadFilterNode.type}set type(value){this._nativeBiquadFilterNode.type=value}getFrequencyResponse(frequencyHz,magResponse,phaseResponse){try{this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz,magResponse,phaseResponse)}catch(err){if(11===err.code)throw createInvalidAccessError();throw err}if(frequencyHz.length!==magResponse.length||magResponse.length!==phaseResponse.length)throw createInvalidAccessError()}})(audioNodeConstructor,createAudioParam,createBiquadFilterNodeRenderer,createInvalidAccessError,createNativeBiquadFilterNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),monitorConnections=((insertElementInSet,isNativeAudioNode)=>(nativeAudioNode,whenConnected,whenDisconnected)=>{const connections=new Set;var connect,disconnect;return nativeAudioNode.connect=(connect=nativeAudioNode.connect,(destination,output=0,input=0)=>{const wasDisconnected=0===connections.size;if(isNativeAudioNode(destination))return connect.call(nativeAudioNode,destination,output,input),insertElementInSet(connections,[destination,output,input],connection=>connection[0]===destination&&connection[1]===output&&connection[2]===input,!0),wasDisconnected&&whenConnected(),destination;connect.call(nativeAudioNode,destination,output),insertElementInSet(connections,[destination,output],connection=>connection[0]===destination&&connection[1]===output,!0),wasDisconnected&&whenConnected()}),nativeAudioNode.disconnect=(disconnect=nativeAudioNode.disconnect,(destinationOrOutput,output,input)=>{const wasConnected=connections.size>0;if(void 0===destinationOrOutput)disconnect.apply(nativeAudioNode),connections.clear();else if("number"==typeof destinationOrOutput){disconnect.call(nativeAudioNode,destinationOrOutput);for(const connection of connections)connection[1]===destinationOrOutput&&connections.delete(connection)}else{isNativeAudioNode(destinationOrOutput)?disconnect.call(nativeAudioNode,destinationOrOutput,output,input):disconnect.call(nativeAudioNode,destinationOrOutput,output);for(const connection of connections)connection[0]!==destinationOrOutput||void 0!==output&&connection[1]!==output||void 0!==input&&connection[2]!==input||connections.delete(connection)}const isDisconnected=0===connections.size;wasConnected&&isDisconnected&&whenDisconnected()}),nativeAudioNode})(insertElementInSet,module_isNativeAudioNode),wrapChannelMergerNode=((createInvalidStateError,monitorConnections)=>(nativeContext,channelMergerNode)=>{channelMergerNode.channelCount=1,channelMergerNode.channelCountMode="explicit",Object.defineProperty(channelMergerNode,"channelCount",{get:()=>1,set:()=>{throw createInvalidStateError()}}),Object.defineProperty(channelMergerNode,"channelCountMode",{get:()=>"explicit",set:()=>{throw createInvalidStateError()}});const audioBufferSourceNode=nativeContext.createBufferSource();monitorConnections(channelMergerNode,()=>{const length=channelMergerNode.numberOfInputs;for(let i=0;i<length;i+=1)audioBufferSourceNode.connect(channelMergerNode,0,i)},()=>audioBufferSourceNode.disconnect(channelMergerNode))})(createInvalidStateError,monitorConnections),createNativeChannelMergerNode=((nativeAudioContextConstructor,wrapChannelMergerNode)=>(nativeContext,options)=>{const nativeChannelMergerNode=nativeContext.createChannelMerger(options.numberOfInputs);return null!==nativeAudioContextConstructor&&"webkitAudioContext"===nativeAudioContextConstructor.name&&wrapChannelMergerNode(nativeContext,nativeChannelMergerNode),assignNativeAudioNodeOptions(nativeChannelMergerNode,options),nativeChannelMergerNode})(nativeAudioContextConstructor,wrapChannelMergerNode),createChannelMergerNodeRenderer=((createNativeChannelMergerNode,getNativeAudioNode,renderInputsOfAudioNode)=>()=>{const renderedNativeAudioNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeAudioNode=renderedNativeAudioNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeAudioNode?Promise.resolve(renderedNativeAudioNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeAudioNode=getNativeAudioNode(proxy);if(!isOwnedByContext(nativeAudioNode,nativeOfflineAudioContext)){const options={channelCount:nativeAudioNode.channelCount,channelCountMode:nativeAudioNode.channelCountMode,channelInterpretation:nativeAudioNode.channelInterpretation,numberOfInputs:nativeAudioNode.numberOfInputs};nativeAudioNode=createNativeChannelMergerNode(nativeOfflineAudioContext,options)}return renderedNativeAudioNodes.set(nativeOfflineAudioContext,nativeAudioNode),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeAudioNode),nativeAudioNode})(proxy,nativeOfflineAudioContext)}}})(createNativeChannelMergerNode,getNativeAudioNode,renderInputsOfAudioNode),channelMergerNodeConstructor=((audioNodeConstructor,createChannelMergerNodeRenderer,createNativeChannelMergerNode,getNativeContext,isNativeOfflineAudioContext)=>class ChannelMergerNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...channel_merger_node_constructor_DEFAULT_OPTIONS,...options};super(context,!1,createNativeChannelMergerNode(nativeContext,mergedOptions),isNativeOfflineAudioContext(nativeContext)?createChannelMergerNodeRenderer():null)}})(audioNodeConstructor,createChannelMergerNodeRenderer,createNativeChannelMergerNode,getNativeContext,isNativeOfflineAudioContext),createChannelSplitterNodeRenderer=((createNativeChannelSplitterNode,getNativeAudioNode,renderInputsOfAudioNode)=>()=>{const renderedNativeAudioNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeAudioNode=renderedNativeAudioNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeAudioNode?Promise.resolve(renderedNativeAudioNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeAudioNode=getNativeAudioNode(proxy);if(!isOwnedByContext(nativeAudioNode,nativeOfflineAudioContext)){const options={channelCount:nativeAudioNode.channelCount,channelCountMode:nativeAudioNode.channelCountMode,channelInterpretation:nativeAudioNode.channelInterpretation,numberOfOutputs:nativeAudioNode.numberOfOutputs};nativeAudioNode=createNativeChannelSplitterNode(nativeOfflineAudioContext,options)}return renderedNativeAudioNodes.set(nativeOfflineAudioContext,nativeAudioNode),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeAudioNode),nativeAudioNode})(proxy,nativeOfflineAudioContext)}}})(createNativeChannelSplitterNode,getNativeAudioNode,renderInputsOfAudioNode),channelSplitterNodeConstructor=((audioNodeConstructor,createChannelSplitterNodeRenderer,createNativeChannelSplitterNode,getNativeContext,isNativeOfflineAudioContext,sanitizeChannelSplitterOptions)=>class ChannelSplitterNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions=sanitizeChannelSplitterOptions({...channel_splitter_node_constructor_DEFAULT_OPTIONS,...options});super(context,!1,createNativeChannelSplitterNode(nativeContext,mergedOptions),isNativeOfflineAudioContext(nativeContext)?createChannelSplitterNodeRenderer():null)}})(audioNodeConstructor,createChannelSplitterNodeRenderer,createNativeChannelSplitterNode,getNativeContext,isNativeOfflineAudioContext,options=>({...options,channelCount:options.numberOfOutputs})),createNativeConstantSourceNodeFaker=((addSilentConnection,createNativeAudioBufferSourceNode,createNativeGainNode,monitorConnections)=>(nativeContext,{offset,...audioNodeOptions})=>{const audioBuffer=nativeContext.createBuffer(1,2,44100),audioBufferSourceNode=createNativeAudioBufferSourceNode(nativeContext,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),gainNode=createNativeGainNode(nativeContext,{...audioNodeOptions,gain:offset}),channelData=audioBuffer.getChannelData(0);channelData[0]=1,channelData[1]=1,audioBufferSourceNode.buffer=audioBuffer,audioBufferSourceNode.loop=!0;const nativeConstantSourceNodeFaker={get bufferSize(){},get channelCount(){return gainNode.channelCount},set channelCount(value){gainNode.channelCount=value},get channelCountMode(){return gainNode.channelCountMode},set channelCountMode(value){gainNode.channelCountMode=value},get channelInterpretation(){return gainNode.channelInterpretation},set channelInterpretation(value){gainNode.channelInterpretation=value},get context(){return gainNode.context},get inputs(){return[]},get numberOfInputs(){return audioBufferSourceNode.numberOfInputs},get numberOfOutputs(){return gainNode.numberOfOutputs},get offset(){return gainNode.gain},get onended(){return audioBufferSourceNode.onended},set onended(value){audioBufferSourceNode.onended=value},addEventListener:(...args)=>audioBufferSourceNode.addEventListener(args[0],args[1],args[2]),dispatchEvent:(...args)=>audioBufferSourceNode.dispatchEvent(args[0]),removeEventListener:(...args)=>audioBufferSourceNode.removeEventListener(args[0],args[1],args[2]),start(when=0){audioBufferSourceNode.start.call(audioBufferSourceNode,when)},stop(when=0){audioBufferSourceNode.stop.call(audioBufferSourceNode,when)}};return addSilentConnection(nativeContext,audioBufferSourceNode),monitorConnections(interceptConnections(nativeConstantSourceNodeFaker,gainNode),()=>audioBufferSourceNode.connect(gainNode),()=>audioBufferSourceNode.disconnect(gainNode))})(addSilentConnection,createNativeAudioBufferSourceNode,createNativeGainNode,monitorConnections),createNativeConstantSourceNode=((addSilentConnection,cacheTestResult,createNativeConstantSourceNodeFaker,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport)=>(nativeContext,options)=>{if(void 0===nativeContext.createConstantSource)return createNativeConstantSourceNodeFaker(nativeContext,options);const nativeConstantSourceNode=nativeContext.createConstantSource();return assignNativeAudioNodeOptions(nativeConstantSourceNode,options),assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode,options,"offset"),cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,()=>testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode),cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,()=>testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode),addSilentConnection(nativeContext,nativeConstantSourceNode),nativeConstantSourceNode})(addSilentConnection,cacheTestResult,createNativeConstantSourceNodeFaker,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport),createConstantSourceNodeRenderer=((connectAudioParam,createNativeConstantSourceNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode)=>()=>{const renderedNativeConstantSourceNodes=new WeakMap;let start=null,stop=null;return{set start(value){start=value},set stop(value){stop=value},render(proxy,nativeOfflineAudioContext){const renderedNativeConstantSourceNode=renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeConstantSourceNode?Promise.resolve(renderedNativeConstantSourceNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeConstantSourceNode=getNativeAudioNode(proxy);const nativeConstantSourceNodeIsOwnedByContext=isOwnedByContext(nativeConstantSourceNode,nativeOfflineAudioContext);if(!nativeConstantSourceNodeIsOwnedByContext){const options={channelCount:nativeConstantSourceNode.channelCount,channelCountMode:nativeConstantSourceNode.channelCountMode,channelInterpretation:nativeConstantSourceNode.channelInterpretation,offset:nativeConstantSourceNode.offset.value};nativeConstantSourceNode=createNativeConstantSourceNode(nativeOfflineAudioContext,options),null!==start&&nativeConstantSourceNode.start(start),null!==stop&&nativeConstantSourceNode.stop(stop)}return renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext,nativeConstantSourceNode),nativeConstantSourceNodeIsOwnedByContext?await connectAudioParam(nativeOfflineAudioContext,proxy.offset,nativeConstantSourceNode.offset):await renderAutomation(nativeOfflineAudioContext,proxy.offset,nativeConstantSourceNode.offset),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeConstantSourceNode),nativeConstantSourceNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeConstantSourceNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),constantSourceNodeConstructor=((audioNodeConstructor,createAudioParam,createConstantSourceNodeRendererFactory,createNativeConstantSourceNode,getNativeContext,isNativeOfflineAudioContext,wrapEventListener)=>class ConstantSourceNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...constant_source_node_constructor_DEFAULT_OPTIONS,...options},nativeConstantSourceNode=createNativeConstantSourceNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext),constantSourceNodeRenderer=isOffline?createConstantSourceNodeRendererFactory():null;super(context,!1,nativeConstantSourceNode,constantSourceNodeRenderer),this._constantSourceNodeRenderer=constantSourceNodeRenderer,this._nativeConstantSourceNode=nativeConstantSourceNode,this._offset=createAudioParam(this,isOffline,nativeConstantSourceNode.offset,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._onended=null}get offset(){return this._offset}get onended(){return this._onended}set onended(value){const wrappedListener="function"==typeof value?wrapEventListener(this,value):null;this._nativeConstantSourceNode.onended=wrappedListener;const nativeOnEnded=this._nativeConstantSourceNode.onended;this._onended=null!==nativeOnEnded&&nativeOnEnded===wrappedListener?value:nativeOnEnded}start(when=0){if(this._nativeConstantSourceNode.start(when),null!==this._constantSourceNodeRenderer&&(this._constantSourceNodeRenderer.start=when),"closed"!==this.context.state){setInternalStateToActive(this);const resetInternalStateToPassive=()=>{this._nativeConstantSourceNode.removeEventListener("ended",resetInternalStateToPassive),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeConstantSourceNode.addEventListener("ended",resetInternalStateToPassive)}}stop(when=0){this._nativeConstantSourceNode.stop(when),null!==this._constantSourceNodeRenderer&&(this._constantSourceNodeRenderer.stop=when)}})(audioNodeConstructor,createAudioParam,createConstantSourceNodeRenderer,createNativeConstantSourceNode,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),createNativeConvolverNode=((createNotSupportedError,overwriteAccessors)=>(nativeContext,options)=>{const nativeConvolverNode=nativeContext.createConvolver();if(assignNativeAudioNodeOptions(nativeConvolverNode,options),options.disableNormalization===nativeConvolverNode.normalize&&(nativeConvolverNode.normalize=!options.disableNormalization),assignNativeAudioNodeOption(nativeConvolverNode,options,"buffer"),options.channelCount>2)throw createNotSupportedError();if(overwriteAccessors(nativeConvolverNode,"channelCount",get=>()=>get.call(nativeConvolverNode),set=>value=>{if(value>2)throw createNotSupportedError();return set.call(nativeConvolverNode,value)}),"max"===options.channelCountMode)throw createNotSupportedError();return overwriteAccessors(nativeConvolverNode,"channelCountMode",get=>()=>get.call(nativeConvolverNode),set=>value=>{if("max"===value)throw createNotSupportedError();return set.call(nativeConvolverNode,value)}),nativeConvolverNode})(createNotSupportedError,overwriteAccessors),createConvolverNodeRenderer=((createNativeConvolverNode,getNativeAudioNode,renderInputsOfAudioNode)=>()=>{const renderedNativeConvolverNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeConvolverNode=renderedNativeConvolverNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeConvolverNode?Promise.resolve(renderedNativeConvolverNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeConvolverNode=getNativeAudioNode(proxy);if(!isOwnedByContext(nativeConvolverNode,nativeOfflineAudioContext)){const options={buffer:nativeConvolverNode.buffer,channelCount:nativeConvolverNode.channelCount,channelCountMode:nativeConvolverNode.channelCountMode,channelInterpretation:nativeConvolverNode.channelInterpretation,disableNormalization:!nativeConvolverNode.normalize};nativeConvolverNode=createNativeConvolverNode(nativeOfflineAudioContext,options)}return renderedNativeConvolverNodes.set(nativeOfflineAudioContext,nativeConvolverNode),isNativeAudioNodeFaker(nativeConvolverNode)?await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeConvolverNode.inputs[0]):await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeConvolverNode),nativeConvolverNode})(proxy,nativeOfflineAudioContext)}}})(createNativeConvolverNode,getNativeAudioNode,renderInputsOfAudioNode),convolverNodeConstructor=((audioNodeConstructor,createConvolverNodeRenderer,createNativeConvolverNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime)=>class ConvolverNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...convolver_node_constructor_DEFAULT_OPTIONS,...options},nativeConvolverNode=createNativeConvolverNode(nativeContext,mergedOptions);super(context,!1,nativeConvolverNode,isNativeOfflineAudioContext(nativeContext)?createConvolverNodeRenderer():null),this._isBufferNullified=!1,this._nativeConvolverNode=nativeConvolverNode,null!==mergedOptions.buffer&&setAudioNodeTailTime(this,mergedOptions.buffer.duration)}get buffer(){return this._isBufferNullified?null:this._nativeConvolverNode.buffer}set buffer(value){if(this._nativeConvolverNode.buffer=value,null===value&&null!==this._nativeConvolverNode.buffer){const nativeContext=this._nativeConvolverNode.context;this._nativeConvolverNode.buffer=nativeContext.createBuffer(1,1,nativeContext.sampleRate),this._isBufferNullified=!0,setAudioNodeTailTime(this,0)}else this._isBufferNullified=!1,setAudioNodeTailTime(this,null===this._nativeConvolverNode.buffer?0:this._nativeConvolverNode.buffer.duration)}get normalize(){return this._nativeConvolverNode.normalize}set normalize(value){this._nativeConvolverNode.normalize=value}})(audioNodeConstructor,createConvolverNodeRenderer,createNativeConvolverNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createDelayNodeRenderer=((connectAudioParam,createNativeDelayNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode)=>maxDelayTime=>{const renderedNativeDelayNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeDelayNode=renderedNativeDelayNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeDelayNode?Promise.resolve(renderedNativeDelayNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeDelayNode=getNativeAudioNode(proxy);const nativeDelayNodeIsOwnedByContext=isOwnedByContext(nativeDelayNode,nativeOfflineAudioContext);if(!nativeDelayNodeIsOwnedByContext){const options={channelCount:nativeDelayNode.channelCount,channelCountMode:nativeDelayNode.channelCountMode,channelInterpretation:nativeDelayNode.channelInterpretation,delayTime:nativeDelayNode.delayTime.value,maxDelayTime};nativeDelayNode=createNativeDelayNode(nativeOfflineAudioContext,options)}return renderedNativeDelayNodes.set(nativeOfflineAudioContext,nativeDelayNode),nativeDelayNodeIsOwnedByContext?await connectAudioParam(nativeOfflineAudioContext,proxy.delayTime,nativeDelayNode.delayTime):await renderAutomation(nativeOfflineAudioContext,proxy.delayTime,nativeDelayNode.delayTime),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeDelayNode),nativeDelayNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeDelayNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),delayNodeConstructor=((audioNodeConstructor,createAudioParam,createDelayNodeRenderer,createNativeDelayNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime)=>class DelayNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...delay_node_constructor_DEFAULT_OPTIONS,...options},nativeDelayNode=createNativeDelayNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext);super(context,!1,nativeDelayNode,isOffline?createDelayNodeRenderer(mergedOptions.maxDelayTime):null),this._delayTime=createAudioParam(this,isOffline,nativeDelayNode.delayTime),setAudioNodeTailTime(this,mergedOptions.maxDelayTime)}get delayTime(){return this._delayTime}})(audioNodeConstructor,createAudioParam,createDelayNodeRenderer,createNativeDelayNode,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createNativeDynamicsCompressorNode=(createNotSupportedError=>(nativeContext,options)=>{const nativeDynamicsCompressorNode=nativeContext.createDynamicsCompressor();if(assignNativeAudioNodeOptions(nativeDynamicsCompressorNode,options),options.channelCount>2)throw createNotSupportedError();if("max"===options.channelCountMode)throw createNotSupportedError();return assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode,options,"attack"),assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode,options,"knee"),assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode,options,"ratio"),assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode,options,"release"),assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode,options,"threshold"),nativeDynamicsCompressorNode})(createNotSupportedError),createDynamicsCompressorNodeRenderer=((connectAudioParam,createNativeDynamicsCompressorNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode)=>()=>{const renderedNativeDynamicsCompressorNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeDynamicsCompressorNode=renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeDynamicsCompressorNode?Promise.resolve(renderedNativeDynamicsCompressorNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeDynamicsCompressorNode=getNativeAudioNode(proxy);const nativeDynamicsCompressorNodeIsOwnedByContext=isOwnedByContext(nativeDynamicsCompressorNode,nativeOfflineAudioContext);if(!nativeDynamicsCompressorNodeIsOwnedByContext){const options={attack:nativeDynamicsCompressorNode.attack.value,channelCount:nativeDynamicsCompressorNode.channelCount,channelCountMode:nativeDynamicsCompressorNode.channelCountMode,channelInterpretation:nativeDynamicsCompressorNode.channelInterpretation,knee:nativeDynamicsCompressorNode.knee.value,ratio:nativeDynamicsCompressorNode.ratio.value,release:nativeDynamicsCompressorNode.release.value,threshold:nativeDynamicsCompressorNode.threshold.value};nativeDynamicsCompressorNode=createNativeDynamicsCompressorNode(nativeOfflineAudioContext,options)}return renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext,nativeDynamicsCompressorNode),nativeDynamicsCompressorNodeIsOwnedByContext?(await connectAudioParam(nativeOfflineAudioContext,proxy.attack,nativeDynamicsCompressorNode.attack),await connectAudioParam(nativeOfflineAudioContext,proxy.knee,nativeDynamicsCompressorNode.knee),await connectAudioParam(nativeOfflineAudioContext,proxy.ratio,nativeDynamicsCompressorNode.ratio),await connectAudioParam(nativeOfflineAudioContext,proxy.release,nativeDynamicsCompressorNode.release),await connectAudioParam(nativeOfflineAudioContext,proxy.threshold,nativeDynamicsCompressorNode.threshold)):(await renderAutomation(nativeOfflineAudioContext,proxy.attack,nativeDynamicsCompressorNode.attack),await renderAutomation(nativeOfflineAudioContext,proxy.knee,nativeDynamicsCompressorNode.knee),await renderAutomation(nativeOfflineAudioContext,proxy.ratio,nativeDynamicsCompressorNode.ratio),await renderAutomation(nativeOfflineAudioContext,proxy.release,nativeDynamicsCompressorNode.release),await renderAutomation(nativeOfflineAudioContext,proxy.threshold,nativeDynamicsCompressorNode.threshold)),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeDynamicsCompressorNode),nativeDynamicsCompressorNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeDynamicsCompressorNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),dynamicsCompressorNodeConstructor=((audioNodeConstructor,createAudioParam,createDynamicsCompressorNodeRenderer,createNativeDynamicsCompressorNode,createNotSupportedError,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime)=>class DynamicsCompressorNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...dynamics_compressor_node_constructor_DEFAULT_OPTIONS,...options},nativeDynamicsCompressorNode=createNativeDynamicsCompressorNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext);super(context,!1,nativeDynamicsCompressorNode,isOffline?createDynamicsCompressorNodeRenderer():null),this._attack=createAudioParam(this,isOffline,nativeDynamicsCompressorNode.attack),this._knee=createAudioParam(this,isOffline,nativeDynamicsCompressorNode.knee),this._nativeDynamicsCompressorNode=nativeDynamicsCompressorNode,this._ratio=createAudioParam(this,isOffline,nativeDynamicsCompressorNode.ratio),this._release=createAudioParam(this,isOffline,nativeDynamicsCompressorNode.release),this._threshold=createAudioParam(this,isOffline,nativeDynamicsCompressorNode.threshold),setAudioNodeTailTime(this,.006)}get attack(){return this._attack}get channelCount(){return this._nativeDynamicsCompressorNode.channelCount}set channelCount(value){const previousChannelCount=this._nativeDynamicsCompressorNode.channelCount;if(this._nativeDynamicsCompressorNode.channelCount=value,value>2)throw this._nativeDynamicsCompressorNode.channelCount=previousChannelCount,createNotSupportedError()}get channelCountMode(){return this._nativeDynamicsCompressorNode.channelCountMode}set channelCountMode(value){const previousChannelCount=this._nativeDynamicsCompressorNode.channelCountMode;if(this._nativeDynamicsCompressorNode.channelCountMode=value,"max"===value)throw this._nativeDynamicsCompressorNode.channelCountMode=previousChannelCount,createNotSupportedError()}get knee(){return this._knee}get ratio(){return this._ratio}get reduction(){return"number"==typeof this._nativeDynamicsCompressorNode.reduction.value?this._nativeDynamicsCompressorNode.reduction.value:this._nativeDynamicsCompressorNode.reduction}get release(){return this._release}get threshold(){return this._threshold}})(audioNodeConstructor,createAudioParam,createDynamicsCompressorNodeRenderer,createNativeDynamicsCompressorNode,createNotSupportedError,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createGainNodeRenderer=((connectAudioParam,createNativeGainNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode)=>()=>{const renderedNativeGainNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeGainNode=renderedNativeGainNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeGainNode?Promise.resolve(renderedNativeGainNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeGainNode=getNativeAudioNode(proxy);const nativeGainNodeIsOwnedByContext=isOwnedByContext(nativeGainNode,nativeOfflineAudioContext);if(!nativeGainNodeIsOwnedByContext){const options={channelCount:nativeGainNode.channelCount,channelCountMode:nativeGainNode.channelCountMode,channelInterpretation:nativeGainNode.channelInterpretation,gain:nativeGainNode.gain.value};nativeGainNode=createNativeGainNode(nativeOfflineAudioContext,options)}return renderedNativeGainNodes.set(nativeOfflineAudioContext,nativeGainNode),nativeGainNodeIsOwnedByContext?await connectAudioParam(nativeOfflineAudioContext,proxy.gain,nativeGainNode.gain):await renderAutomation(nativeOfflineAudioContext,proxy.gain,nativeGainNode.gain),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeGainNode),nativeGainNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeGainNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),gainNodeConstructor=((audioNodeConstructor,createAudioParam,createGainNodeRenderer,createNativeGainNode,getNativeContext,isNativeOfflineAudioContext)=>class GainNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...gain_node_constructor_DEFAULT_OPTIONS,...options},nativeGainNode=createNativeGainNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext);super(context,!1,nativeGainNode,isOffline?createGainNodeRenderer():null),this._gain=createAudioParam(this,isOffline,nativeGainNode.gain,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT)}get gain(){return this._gain}})(audioNodeConstructor,createAudioParam,createGainNodeRenderer,createNativeGainNode,getNativeContext,isNativeOfflineAudioContext),createNativeIIRFilterNodeFaker=((createInvalidAccessError,createInvalidStateError,createNativeScriptProcessorNode,createNotSupportedError)=>(nativeContext,baseLatency,{channelCount,channelCountMode,channelInterpretation,feedback,feedforward})=>{const bufferSize=computeBufferSize(baseLatency,nativeContext.sampleRate),convertedFeedback=feedback instanceof Float64Array?feedback:new Float64Array(feedback),convertedFeedforward=feedforward instanceof Float64Array?feedforward:new Float64Array(feedforward),feedbackLength=convertedFeedback.length,feedforwardLength=convertedFeedforward.length,minLength=Math.min(feedbackLength,feedforwardLength);if(0===feedbackLength||feedbackLength>20)throw createNotSupportedError();if(0===convertedFeedback[0])throw createInvalidStateError();if(0===feedforwardLength||feedforwardLength>20)throw createNotSupportedError();if(0===convertedFeedforward[0])throw createInvalidStateError();if(1!==convertedFeedback[0]){for(let i=0;i<feedforwardLength;i+=1)convertedFeedforward[i]/=convertedFeedback[0];for(let i=1;i<feedbackLength;i+=1)convertedFeedback[i]/=convertedFeedback[0]}const scriptProcessorNode=createNativeScriptProcessorNode(nativeContext,bufferSize,channelCount,channelCount);scriptProcessorNode.channelCount=channelCount,scriptProcessorNode.channelCountMode=channelCountMode,scriptProcessorNode.channelInterpretation=channelInterpretation;const bufferIndexes=[],xBuffers=[],yBuffers=[];for(let i=0;i<channelCount;i+=1){bufferIndexes.push(0);const xBuffer=new Float32Array(32),yBuffer=new Float32Array(32);xBuffer.fill(0),yBuffer.fill(0),xBuffers.push(xBuffer),yBuffers.push(yBuffer)}scriptProcessorNode.onaudioprocess=event=>{const inputBuffer=event.inputBuffer,outputBuffer=event.outputBuffer,numberOfChannels=inputBuffer.numberOfChannels;for(let i=0;i<numberOfChannels;i+=1){const input=inputBuffer.getChannelData(i),output=outputBuffer.getChannelData(i);bufferIndexes[i]=filterBuffer(convertedFeedback,feedbackLength,convertedFeedforward,feedforwardLength,minLength,xBuffers[i],yBuffers[i],bufferIndexes[i],32,input,output)}};const nyquist=nativeContext.sampleRate/2;return interceptConnections({get bufferSize(){return bufferSize},get channelCount(){return scriptProcessorNode.channelCount},set channelCount(value){scriptProcessorNode.channelCount=value},get channelCountMode(){return scriptProcessorNode.channelCountMode},set channelCountMode(value){scriptProcessorNode.channelCountMode=value},get channelInterpretation(){return scriptProcessorNode.channelInterpretation},set channelInterpretation(value){scriptProcessorNode.channelInterpretation=value},get context(){return scriptProcessorNode.context},get inputs(){return[scriptProcessorNode]},get numberOfInputs(){return scriptProcessorNode.numberOfInputs},get numberOfOutputs(){return scriptProcessorNode.numberOfOutputs},addEventListener:(...args)=>scriptProcessorNode.addEventListener(args[0],args[1],args[2]),dispatchEvent:(...args)=>scriptProcessorNode.dispatchEvent(args[0]),getFrequencyResponse(frequencyHz,magResponse,phaseResponse){if(frequencyHz.length!==magResponse.length||magResponse.length!==phaseResponse.length)throw createInvalidAccessError();const length=frequencyHz.length;for(let i=0;i<length;i+=1){const omega=-Math.PI*(frequencyHz[i]/nyquist),z=[Math.cos(omega),Math.sin(omega)],response=divide(evaluatePolynomial(convertedFeedforward,z),evaluatePolynomial(convertedFeedback,z));magResponse[i]=Math.sqrt(response[0]*response[0]+response[1]*response[1]),phaseResponse[i]=Math.atan2(response[1],response[0])}},removeEventListener:(...args)=>scriptProcessorNode.removeEventListener(args[0],args[1],args[2])},scriptProcessorNode)})(createInvalidAccessError,createInvalidStateError,createNativeScriptProcessorNode,createNotSupportedError),renderNativeOfflineAudioContext=((cacheTestResult,createNativeGainNode,createNativeScriptProcessorNode,testOfflineAudioContextCurrentTimeSupport)=>nativeOfflineAudioContext=>cacheTestResult(testPromiseSupport,()=>testPromiseSupport(nativeOfflineAudioContext))?Promise.resolve(cacheTestResult(testOfflineAudioContextCurrentTimeSupport,testOfflineAudioContextCurrentTimeSupport)).then(isOfflineAudioContextCurrentTimeSupported=>{if(!isOfflineAudioContextCurrentTimeSupported){const scriptProcessorNode=createNativeScriptProcessorNode(nativeOfflineAudioContext,512,0,1);nativeOfflineAudioContext.oncomplete=()=>{scriptProcessorNode.onaudioprocess=null,scriptProcessorNode.disconnect()},scriptProcessorNode.onaudioprocess=()=>nativeOfflineAudioContext.currentTime,scriptProcessorNode.connect(nativeOfflineAudioContext.destination)}return nativeOfflineAudioContext.startRendering()}):new Promise(resolve=>{const gainNode=createNativeGainNode(nativeOfflineAudioContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});nativeOfflineAudioContext.oncomplete=event=>{gainNode.disconnect(),resolve(event.renderedBuffer)},gainNode.connect(nativeOfflineAudioContext.destination),nativeOfflineAudioContext.startRendering()}))(cacheTestResult,createNativeGainNode,createNativeScriptProcessorNode,((createNativeGainNode,nativeOfflineAudioContextConstructor)=>()=>{if(null===nativeOfflineAudioContextConstructor)return Promise.resolve(!1);const nativeOfflineAudioContext=new nativeOfflineAudioContextConstructor(1,1,44100),gainNode=createNativeGainNode(nativeOfflineAudioContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});return new Promise(resolve=>{nativeOfflineAudioContext.oncomplete=()=>{gainNode.disconnect(),resolve(0!==nativeOfflineAudioContext.currentTime)},nativeOfflineAudioContext.startRendering()})})(createNativeGainNode,nativeOfflineAudioContextConstructor)),createIIRFilterNodeRenderer=((createNativeAudioBufferSourceNode,getNativeAudioNode,nativeOfflineAudioContextConstructor,renderInputsOfAudioNode,renderNativeOfflineAudioContext)=>(feedback,feedforward)=>{const renderedNativeAudioNodes=new WeakMap;let filteredBufferPromise=null;const createAudioNode=async(proxy,nativeOfflineAudioContext)=>{let nativeAudioBufferSourceNode=null,nativeIIRFilterNode=getNativeAudioNode(proxy);const nativeIIRFilterNodeIsOwnedByContext=isOwnedByContext(nativeIIRFilterNode,nativeOfflineAudioContext);if(void 0===nativeOfflineAudioContext.createIIRFilter?nativeAudioBufferSourceNode=createNativeAudioBufferSourceNode(nativeOfflineAudioContext,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}):nativeIIRFilterNodeIsOwnedByContext||(nativeIIRFilterNode=nativeOfflineAudioContext.createIIRFilter(feedforward,feedback)),renderedNativeAudioNodes.set(nativeOfflineAudioContext,null===nativeAudioBufferSourceNode?nativeIIRFilterNode:nativeAudioBufferSourceNode),null!==nativeAudioBufferSourceNode){if(null===filteredBufferPromise){if(null===nativeOfflineAudioContextConstructor)throw new Error("Missing the native OfflineAudioContext constructor.");const partialOfflineAudioContext=new nativeOfflineAudioContextConstructor(proxy.context.destination.channelCount,proxy.context.length,nativeOfflineAudioContext.sampleRate);filteredBufferPromise=(async()=>{await renderInputsOfAudioNode(proxy,partialOfflineAudioContext,partialOfflineAudioContext.destination);return((renderedBuffer,nativeOfflineAudioContext,feedback,feedforward)=>{const convertedFeedback=feedback instanceof Float64Array?feedback:new Float64Array(feedback),convertedFeedforward=feedforward instanceof Float64Array?feedforward:new Float64Array(feedforward),feedbackLength=convertedFeedback.length,feedforwardLength=convertedFeedforward.length,minLength=Math.min(feedbackLength,feedforwardLength);if(1!==convertedFeedback[0]){for(let i=0;i<feedbackLength;i+=1)convertedFeedforward[i]/=convertedFeedback[0];for(let i=1;i<feedforwardLength;i+=1)convertedFeedback[i]/=convertedFeedback[0]}const xBuffer=new Float32Array(32),yBuffer=new Float32Array(32),filteredBuffer=nativeOfflineAudioContext.createBuffer(renderedBuffer.numberOfChannels,renderedBuffer.length,renderedBuffer.sampleRate),numberOfChannels=renderedBuffer.numberOfChannels;for(let i=0;i<numberOfChannels;i+=1){const input=renderedBuffer.getChannelData(i),output=filteredBuffer.getChannelData(i);xBuffer.fill(0),yBuffer.fill(0),filterBuffer(convertedFeedback,feedbackLength,convertedFeedforward,feedforwardLength,minLength,xBuffer,yBuffer,0,32,input,output)}return filteredBuffer})(await renderNativeOfflineAudioContext(partialOfflineAudioContext),nativeOfflineAudioContext,feedback,feedforward)})()}const filteredBuffer=await filteredBufferPromise;return nativeAudioBufferSourceNode.buffer=filteredBuffer,nativeAudioBufferSourceNode.start(0),nativeAudioBufferSourceNode}return await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeIIRFilterNode),nativeIIRFilterNode};return{render(proxy,nativeOfflineAudioContext){const renderedNativeAudioNode=renderedNativeAudioNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeAudioNode?Promise.resolve(renderedNativeAudioNode):createAudioNode(proxy,nativeOfflineAudioContext)}}})(createNativeAudioBufferSourceNode,getNativeAudioNode,nativeOfflineAudioContextConstructor,renderInputsOfAudioNode,renderNativeOfflineAudioContext),createNativeIIRFilterNode=(createNativeIIRFilterNodeFaker=>(nativeContext,baseLatency,options)=>{if(void 0===nativeContext.createIIRFilter)return createNativeIIRFilterNodeFaker(nativeContext,baseLatency,options);const nativeIIRFilterNode=nativeContext.createIIRFilter(options.feedforward,options.feedback);return assignNativeAudioNodeOptions(nativeIIRFilterNode,options),nativeIIRFilterNode})(createNativeIIRFilterNodeFaker),iIRFilterNodeConstructor=((audioNodeConstructor,createNativeIIRFilterNode,createIIRFilterNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime)=>class IIRFilterNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),isOffline=isNativeOfflineAudioContext(nativeContext),mergedOptions={...iir_filter_node_constructor_DEFAULT_OPTIONS,...options},nativeIIRFilterNode=createNativeIIRFilterNode(nativeContext,isOffline?null:context.baseLatency,mergedOptions);super(context,!1,nativeIIRFilterNode,isOffline?createIIRFilterNodeRenderer(mergedOptions.feedback,mergedOptions.feedforward):null),(nativeIIRFilterNode=>{var getFrequencyResponse;nativeIIRFilterNode.getFrequencyResponse=(getFrequencyResponse=nativeIIRFilterNode.getFrequencyResponse,(frequencyHz,magResponse,phaseResponse)=>{if(frequencyHz.length!==magResponse.length||magResponse.length!==phaseResponse.length)throw createInvalidAccessError();return getFrequencyResponse.call(nativeIIRFilterNode,frequencyHz,magResponse,phaseResponse)})})(nativeIIRFilterNode),this._nativeIIRFilterNode=nativeIIRFilterNode,setAudioNodeTailTime(this,1)}getFrequencyResponse(frequencyHz,magResponse,phaseResponse){return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz,magResponse,phaseResponse)}})(audioNodeConstructor,createNativeIIRFilterNode,createIIRFilterNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createAudioListener=((createAudioParam,createNativeChannelMergerNode,createNativeConstantSourceNode,createNativeScriptProcessorNode,createNotSupportedError,getFirstSample,isNativeOfflineAudioContext,overwriteAccessors)=>(context,nativeContext)=>{const nativeListener=nativeContext.listener,{forwardX,forwardY,forwardZ,positionX,positionY,positionZ,upX,upY,upZ}=void 0===nativeListener.forwardX?(()=>{const buffer=new Float32Array(1),channelMergerNode=createNativeChannelMergerNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:9}),isOffline=isNativeOfflineAudioContext(nativeContext);let isScriptProcessorNodeCreated=!1,lastOrientation=[0,0,-1,0,1,0],lastPosition=[0,0,0];const createScriptProcessorNode=()=>{if(isScriptProcessorNodeCreated)return;isScriptProcessorNodeCreated=!0;const scriptProcessorNode=createNativeScriptProcessorNode(nativeContext,256,9,0);scriptProcessorNode.onaudioprocess=({inputBuffer})=>{const orientation=[getFirstSample(inputBuffer,buffer,0),getFirstSample(inputBuffer,buffer,1),getFirstSample(inputBuffer,buffer,2),getFirstSample(inputBuffer,buffer,3),getFirstSample(inputBuffer,buffer,4),getFirstSample(inputBuffer,buffer,5)];orientation.some((value,index)=>value!==lastOrientation[index])&&(nativeListener.setOrientation(...orientation),lastOrientation=orientation);const positon=[getFirstSample(inputBuffer,buffer,6),getFirstSample(inputBuffer,buffer,7),getFirstSample(inputBuffer,buffer,8)];positon.some((value,index)=>value!==lastPosition[index])&&(nativeListener.setPosition(...positon),lastPosition=positon)},channelMergerNode.connect(scriptProcessorNode)},createSetOrientation=index=>value=>{value!==lastOrientation[index]&&(lastOrientation[index]=value,nativeListener.setOrientation(...lastOrientation))},createSetPosition=index=>value=>{value!==lastPosition[index]&&(lastPosition[index]=value,nativeListener.setPosition(...lastPosition))},createFakeAudioParam=(input,initialValue,setValue)=>{const constantSourceNode=createNativeConstantSourceNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:initialValue});constantSourceNode.connect(channelMergerNode,0,input),constantSourceNode.start(),Object.defineProperty(constantSourceNode.offset,"defaultValue",{get:()=>initialValue});const audioParam=createAudioParam({context},isOffline,constantSourceNode.offset,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT);var cancelAndHoldAtTime,cancelScheduledValues,exponentialRampToValueAtTime,linearRampToValueAtTime,setTargetAtTime,setValueAtTime,setValueCurveAtTime;return overwriteAccessors(audioParam,"value",get=>()=>get.call(audioParam),set=>value=>{try{set.call(audioParam,value)}catch(err){if(9!==err.code)throw err}createScriptProcessorNode(),isOffline&&setValue(value)}),audioParam.cancelAndHoldAtTime=(cancelAndHoldAtTime=audioParam.cancelAndHoldAtTime,isOffline?()=>{throw createNotSupportedError()}:(...args)=>{const value=cancelAndHoldAtTime.apply(audioParam,args);return createScriptProcessorNode(),value}),audioParam.cancelScheduledValues=(cancelScheduledValues=audioParam.cancelScheduledValues,isOffline?()=>{throw createNotSupportedError()}:(...args)=>{const value=cancelScheduledValues.apply(audioParam,args);return createScriptProcessorNode(),value}),audioParam.exponentialRampToValueAtTime=(exponentialRampToValueAtTime=audioParam.exponentialRampToValueAtTime,isOffline?()=>{throw createNotSupportedError()}:(...args)=>{const value=exponentialRampToValueAtTime.apply(audioParam,args);return createScriptProcessorNode(),value}),audioParam.linearRampToValueAtTime=(linearRampToValueAtTime=audioParam.linearRampToValueAtTime,isOffline?()=>{throw createNotSupportedError()}:(...args)=>{const value=linearRampToValueAtTime.apply(audioParam,args);return createScriptProcessorNode(),value}),audioParam.setTargetAtTime=(setTargetAtTime=audioParam.setTargetAtTime,isOffline?()=>{throw createNotSupportedError()}:(...args)=>{const value=setTargetAtTime.apply(audioParam,args);return createScriptProcessorNode(),value}),audioParam.setValueAtTime=(setValueAtTime=audioParam.setValueAtTime,isOffline?()=>{throw createNotSupportedError()}:(...args)=>{const value=setValueAtTime.apply(audioParam,args);return createScriptProcessorNode(),value}),audioParam.setValueCurveAtTime=(setValueCurveAtTime=audioParam.setValueCurveAtTime,isOffline?()=>{throw createNotSupportedError()}:(...args)=>{const value=setValueCurveAtTime.apply(audioParam,args);return createScriptProcessorNode(),value}),audioParam};return{forwardX:createFakeAudioParam(0,0,createSetOrientation(0)),forwardY:createFakeAudioParam(1,0,createSetOrientation(1)),forwardZ:createFakeAudioParam(2,-1,createSetOrientation(2)),positionX:createFakeAudioParam(6,0,createSetPosition(0)),positionY:createFakeAudioParam(7,0,createSetPosition(1)),positionZ:createFakeAudioParam(8,0,createSetPosition(2)),upX:createFakeAudioParam(3,0,createSetOrientation(3)),upY:createFakeAudioParam(4,1,createSetOrientation(4)),upZ:createFakeAudioParam(5,0,createSetOrientation(5))}})():nativeListener;return{get forwardX(){return forwardX},get forwardY(){return forwardY},get forwardZ(){return forwardZ},get positionX(){return positionX},get positionY(){return positionY},get positionZ(){return positionZ},get upX(){return upX},get upY(){return upY},get upZ(){return upZ}}})(createAudioParam,createNativeChannelMergerNode,createNativeConstantSourceNode,createNativeScriptProcessorNode,createNotSupportedError,getFirstSample,isNativeOfflineAudioContext,overwriteAccessors),unrenderedAudioWorkletNodeStore=new WeakMap,minimalBaseAudioContextConstructor=((audioDestinationNodeConstructor,createAudioListener,eventTargetConstructor,isNativeOfflineAudioContext,unrenderedAudioWorkletNodeStore,wrapEventListener)=>class MinimalBaseAudioContext extends eventTargetConstructor{constructor(_nativeContext,numberOfChannels){super(_nativeContext),this._nativeContext=_nativeContext,CONTEXT_STORE.set(this,_nativeContext),isNativeOfflineAudioContext(_nativeContext)&&unrenderedAudioWorkletNodeStore.set(_nativeContext,new Set),this._destination=new audioDestinationNodeConstructor(this,numberOfChannels),this._listener=createAudioListener(this,_nativeContext),this._onstatechange=null}get currentTime(){return this._nativeContext.currentTime}get destination(){return this._destination}get listener(){return this._listener}get onstatechange(){return this._onstatechange}set onstatechange(value){const wrappedListener="function"==typeof value?wrapEventListener(this,value):null;this._nativeContext.onstatechange=wrappedListener;const nativeOnStateChange=this._nativeContext.onstatechange;this._onstatechange=null!==nativeOnStateChange&&nativeOnStateChange===wrappedListener?value:nativeOnStateChange}get sampleRate(){return this._nativeContext.sampleRate}get state(){return this._nativeContext.state}})(audioDestinationNodeConstructor,createAudioListener,eventTargetConstructor,isNativeOfflineAudioContext,unrenderedAudioWorkletNodeStore,wrapEventListener),createNativeOscillatorNode=((addSilentConnection,cacheTestResult,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls)=>(nativeContext,options)=>{const nativeOscillatorNode=nativeContext.createOscillator();return assignNativeAudioNodeOptions(nativeOscillatorNode,options),assignNativeAudioNodeAudioParamValue(nativeOscillatorNode,options,"detune"),assignNativeAudioNodeAudioParamValue(nativeOscillatorNode,options,"frequency"),void 0!==options.periodicWave?nativeOscillatorNode.setPeriodicWave(options.periodicWave):assignNativeAudioNodeOption(nativeOscillatorNode,options,"type"),cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,()=>testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext))||wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode),cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,()=>testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext))||wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode,nativeContext),cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,()=>testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext))||wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode),addSilentConnection(nativeContext,nativeOscillatorNode),nativeOscillatorNode})(addSilentConnection,cacheTestResult,testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls),createOscillatorNodeRenderer=((connectAudioParam,createNativeOscillatorNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode)=>()=>{const renderedNativeOscillatorNodes=new WeakMap;let periodicWave=null,start=null,stop=null;return{set periodicWave(value){periodicWave=value},set start(value){start=value},set stop(value){stop=value},render(proxy,nativeOfflineAudioContext){const renderedNativeOscillatorNode=renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeOscillatorNode?Promise.resolve(renderedNativeOscillatorNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeOscillatorNode=getNativeAudioNode(proxy);const nativeOscillatorNodeIsOwnedByContext=isOwnedByContext(nativeOscillatorNode,nativeOfflineAudioContext);if(!nativeOscillatorNodeIsOwnedByContext){const options={channelCount:nativeOscillatorNode.channelCount,channelCountMode:nativeOscillatorNode.channelCountMode,channelInterpretation:nativeOscillatorNode.channelInterpretation,detune:nativeOscillatorNode.detune.value,frequency:nativeOscillatorNode.frequency.value,periodicWave:null===periodicWave?void 0:periodicWave,type:nativeOscillatorNode.type};nativeOscillatorNode=createNativeOscillatorNode(nativeOfflineAudioContext,options),null!==start&&nativeOscillatorNode.start(start),null!==stop&&nativeOscillatorNode.stop(stop)}return renderedNativeOscillatorNodes.set(nativeOfflineAudioContext,nativeOscillatorNode),nativeOscillatorNodeIsOwnedByContext?(await connectAudioParam(nativeOfflineAudioContext,proxy.detune,nativeOscillatorNode.detune),await connectAudioParam(nativeOfflineAudioContext,proxy.frequency,nativeOscillatorNode.frequency)):(await renderAutomation(nativeOfflineAudioContext,proxy.detune,nativeOscillatorNode.detune),await renderAutomation(nativeOfflineAudioContext,proxy.frequency,nativeOscillatorNode.frequency)),await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeOscillatorNode),nativeOscillatorNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeOscillatorNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),oscillatorNodeConstructor=((audioNodeConstructor,createAudioParam,createNativeOscillatorNode,createOscillatorNodeRenderer,getNativeContext,isNativeOfflineAudioContext,wrapEventListener)=>class OscillatorNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...oscillator_node_constructor_DEFAULT_OPTIONS,...options},nativeOscillatorNode=createNativeOscillatorNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext),oscillatorNodeRenderer=isOffline?createOscillatorNodeRenderer():null,nyquist=context.sampleRate/2;super(context,!1,nativeOscillatorNode,oscillatorNodeRenderer),this._detune=createAudioParam(this,isOffline,nativeOscillatorNode.detune,153600,-153600),this._frequency=createAudioParam(this,isOffline,nativeOscillatorNode.frequency,nyquist,-nyquist),this._nativeOscillatorNode=nativeOscillatorNode,this._onended=null,this._oscillatorNodeRenderer=oscillatorNodeRenderer,null!==this._oscillatorNodeRenderer&&void 0!==mergedOptions.periodicWave&&(this._oscillatorNodeRenderer.periodicWave=mergedOptions.periodicWave)}get detune(){return this._detune}get frequency(){return this._frequency}get onended(){return this._onended}set onended(value){const wrappedListener="function"==typeof value?wrapEventListener(this,value):null;this._nativeOscillatorNode.onended=wrappedListener;const nativeOnEnded=this._nativeOscillatorNode.onended;this._onended=null!==nativeOnEnded&&nativeOnEnded===wrappedListener?value:nativeOnEnded}get type(){return this._nativeOscillatorNode.type}set type(value){this._nativeOscillatorNode.type=value,null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.periodicWave=null)}setPeriodicWave(periodicWave){this._nativeOscillatorNode.setPeriodicWave(periodicWave),null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.periodicWave=periodicWave)}start(when=0){if(this._nativeOscillatorNode.start(when),null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.start=when),"closed"!==this.context.state){setInternalStateToActive(this);const resetInternalStateToPassive=()=>{this._nativeOscillatorNode.removeEventListener("ended",resetInternalStateToPassive),isActiveAudioNode(this)&&setInternalStateToPassive(this)};this._nativeOscillatorNode.addEventListener("ended",resetInternalStateToPassive)}}stop(when=0){this._nativeOscillatorNode.stop(when),null!==this._oscillatorNodeRenderer&&(this._oscillatorNodeRenderer.stop=when)}})(audioNodeConstructor,createAudioParam,createNativeOscillatorNode,createOscillatorNodeRenderer,getNativeContext,isNativeOfflineAudioContext,wrapEventListener),createConnectedNativeAudioBufferSourceNode=(createNativeAudioBufferSourceNode=>(nativeContext,nativeAudioNode)=>{const nativeAudioBufferSourceNode=createNativeAudioBufferSourceNode(nativeContext,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),nativeAudioBuffer=nativeContext.createBuffer(1,2,44100);return nativeAudioBufferSourceNode.buffer=nativeAudioBuffer,nativeAudioBufferSourceNode.loop=!0,nativeAudioBufferSourceNode.connect(nativeAudioNode),nativeAudioBufferSourceNode.start(),()=>{nativeAudioBufferSourceNode.stop(),nativeAudioBufferSourceNode.disconnect(nativeAudioNode)}})(createNativeAudioBufferSourceNode),createNativeWaveShaperNodeFaker=((createConnectedNativeAudioBufferSourceNode,createInvalidStateError,createNativeGainNode,isDCCurve,monitorConnections)=>(nativeContext,{curve,oversample,...audioNodeOptions})=>{const negativeWaveShaperNode=nativeContext.createWaveShaper(),positiveWaveShaperNode=nativeContext.createWaveShaper();assignNativeAudioNodeOptions(negativeWaveShaperNode,audioNodeOptions),assignNativeAudioNodeOptions(positiveWaveShaperNode,audioNodeOptions);const inputGainNode=createNativeGainNode(nativeContext,{...audioNodeOptions,gain:1}),invertGainNode=createNativeGainNode(nativeContext,{...audioNodeOptions,gain:-1}),outputGainNode=createNativeGainNode(nativeContext,{...audioNodeOptions,gain:1}),revertGainNode=createNativeGainNode(nativeContext,{...audioNodeOptions,gain:-1});let disconnectNativeAudioBufferSourceNode=null,isConnected=!1,unmodifiedCurve=null;const nativeWaveShaperNodeFaker={get bufferSize(){},get channelCount(){return negativeWaveShaperNode.channelCount},set channelCount(value){inputGainNode.channelCount=value,invertGainNode.channelCount=value,negativeWaveShaperNode.channelCount=value,outputGainNode.channelCount=value,positiveWaveShaperNode.channelCount=value,revertGainNode.channelCount=value},get channelCountMode(){return negativeWaveShaperNode.channelCountMode},set channelCountMode(value){inputGainNode.channelCountMode=value,invertGainNode.channelCountMode=value,negativeWaveShaperNode.channelCountMode=value,outputGainNode.channelCountMode=value,positiveWaveShaperNode.channelCountMode=value,revertGainNode.channelCountMode=value},get channelInterpretation(){return negativeWaveShaperNode.channelInterpretation},set channelInterpretation(value){inputGainNode.channelInterpretation=value,invertGainNode.channelInterpretation=value,negativeWaveShaperNode.channelInterpretation=value,outputGainNode.channelInterpretation=value,positiveWaveShaperNode.channelInterpretation=value,revertGainNode.channelInterpretation=value},get context(){return negativeWaveShaperNode.context},get curve(){return unmodifiedCurve},set curve(value){if(null!==value&&value.length<2)throw createInvalidStateError();if(null===value)negativeWaveShaperNode.curve=value,positiveWaveShaperNode.curve=value;else{const curveLength=value.length,negativeCurve=new Float32Array(curveLength+2-curveLength%2),positiveCurve=new Float32Array(curveLength+2-curveLength%2);negativeCurve[0]=value[0],positiveCurve[0]=-value[curveLength-1];const length=Math.ceil((curveLength+1)/2),centerIndex=(curveLength+1)/2-1;for(let i=1;i<length;i+=1){const theoreticIndex=i/length*centerIndex,lowerIndex=Math.floor(theoreticIndex),upperIndex=Math.ceil(theoreticIndex);negativeCurve[i]=lowerIndex===upperIndex?value[lowerIndex]:(1-(theoreticIndex-lowerIndex))*value[lowerIndex]+(1-(upperIndex-theoreticIndex))*value[upperIndex],positiveCurve[i]=lowerIndex===upperIndex?-value[curveLength-1-lowerIndex]:-(1-(theoreticIndex-lowerIndex))*value[curveLength-1-lowerIndex]-(1-(upperIndex-theoreticIndex))*value[curveLength-1-upperIndex]}negativeCurve[length]=curveLength%2==1?value[length-1]:(value[length-2]+value[length-1])/2,negativeWaveShaperNode.curve=negativeCurve,positiveWaveShaperNode.curve=positiveCurve}unmodifiedCurve=value,isConnected&&(isDCCurve(unmodifiedCurve)&&null===disconnectNativeAudioBufferSourceNode?disconnectNativeAudioBufferSourceNode=createConnectedNativeAudioBufferSourceNode(nativeContext,inputGainNode):null!==disconnectNativeAudioBufferSourceNode&&(disconnectNativeAudioBufferSourceNode(),disconnectNativeAudioBufferSourceNode=null))},get inputs(){return[inputGainNode]},get numberOfInputs(){return negativeWaveShaperNode.numberOfInputs},get numberOfOutputs(){return negativeWaveShaperNode.numberOfOutputs},get oversample(){return negativeWaveShaperNode.oversample},set oversample(value){negativeWaveShaperNode.oversample=value,positiveWaveShaperNode.oversample=value},addEventListener:(...args)=>inputGainNode.addEventListener(args[0],args[1],args[2]),dispatchEvent:(...args)=>inputGainNode.dispatchEvent(args[0]),removeEventListener:(...args)=>inputGainNode.removeEventListener(args[0],args[1],args[2])};null!==curve&&(nativeWaveShaperNodeFaker.curve=curve instanceof Float32Array?curve:new Float32Array(curve)),oversample!==nativeWaveShaperNodeFaker.oversample&&(nativeWaveShaperNodeFaker.oversample=oversample);return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker,outputGainNode),()=>{inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode),inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode),isConnected=!0,isDCCurve(unmodifiedCurve)&&(disconnectNativeAudioBufferSourceNode=createConnectedNativeAudioBufferSourceNode(nativeContext,inputGainNode))},()=>{inputGainNode.disconnect(negativeWaveShaperNode),negativeWaveShaperNode.disconnect(outputGainNode),inputGainNode.disconnect(invertGainNode),invertGainNode.disconnect(positiveWaveShaperNode),positiveWaveShaperNode.disconnect(revertGainNode),revertGainNode.disconnect(outputGainNode),isConnected=!1,null!==disconnectNativeAudioBufferSourceNode&&(disconnectNativeAudioBufferSourceNode(),disconnectNativeAudioBufferSourceNode=null)})})(createConnectedNativeAudioBufferSourceNode,createInvalidStateError,createNativeGainNode,isDCCurve,monitorConnections),createNativeWaveShaperNode=((createConnectedNativeAudioBufferSourceNode,createInvalidStateError,createNativeWaveShaperNodeFaker,isDCCurve,monitorConnections,nativeAudioContextConstructor,overwriteAccessors)=>(nativeContext,options)=>{const nativeWaveShaperNode=nativeContext.createWaveShaper();if(null!==nativeAudioContextConstructor&&"webkitAudioContext"===nativeAudioContextConstructor.name&&void 0===nativeContext.createGain().gain.automationRate)return createNativeWaveShaperNodeFaker(nativeContext,options);assignNativeAudioNodeOptions(nativeWaveShaperNode,options);const curve=null===options.curve||options.curve instanceof Float32Array?options.curve:new Float32Array(options.curve);if(null!==curve&&curve.length<2)throw createInvalidStateError();assignNativeAudioNodeOption(nativeWaveShaperNode,{curve},"curve"),assignNativeAudioNodeOption(nativeWaveShaperNode,options,"oversample");let disconnectNativeAudioBufferSourceNode=null,isConnected=!1;overwriteAccessors(nativeWaveShaperNode,"curve",get=>()=>get.call(nativeWaveShaperNode),set=>value=>(set.call(nativeWaveShaperNode,value),isConnected&&(isDCCurve(value)&&null===disconnectNativeAudioBufferSourceNode?disconnectNativeAudioBufferSourceNode=createConnectedNativeAudioBufferSourceNode(nativeContext,nativeWaveShaperNode):isDCCurve(value)||null===disconnectNativeAudioBufferSourceNode||(disconnectNativeAudioBufferSourceNode(),disconnectNativeAudioBufferSourceNode=null)),value));return monitorConnections(nativeWaveShaperNode,()=>{isConnected=!0,isDCCurve(nativeWaveShaperNode.curve)&&(disconnectNativeAudioBufferSourceNode=createConnectedNativeAudioBufferSourceNode(nativeContext,nativeWaveShaperNode))},()=>{isConnected=!1,null!==disconnectNativeAudioBufferSourceNode&&(disconnectNativeAudioBufferSourceNode(),disconnectNativeAudioBufferSourceNode=null)})})(createConnectedNativeAudioBufferSourceNode,createInvalidStateError,createNativeWaveShaperNodeFaker,isDCCurve,monitorConnections,nativeAudioContextConstructor,overwriteAccessors),createNativePannerNodeFaker=((connectNativeAudioNodeToNativeAudioNode,createInvalidStateError,createNativeChannelMergerNode,createNativeGainNode,createNativeScriptProcessorNode,createNativeWaveShaperNode,createNotSupportedError,disconnectNativeAudioNodeFromNativeAudioNode,getFirstSample,monitorConnections)=>(nativeContext,{coneInnerAngle,coneOuterAngle,coneOuterGain,distanceModel,maxDistance,orientationX,orientationY,orientationZ,panningModel,positionX,positionY,positionZ,refDistance,rolloffFactor,...audioNodeOptions})=>{const pannerNode=nativeContext.createPanner();if(audioNodeOptions.channelCount>2)throw createNotSupportedError();if("max"===audioNodeOptions.channelCountMode)throw createNotSupportedError();assignNativeAudioNodeOptions(pannerNode,audioNodeOptions);const SINGLE_CHANNEL_OPTIONS={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},channelMergerNode=createNativeChannelMergerNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,channelInterpretation:"speakers",numberOfInputs:6}),inputGainNode=createNativeGainNode(nativeContext,{...audioNodeOptions,gain:1}),orientationXGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:1}),orientationYGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),orientationZGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),positionXGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),positionYGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),positionZGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),scriptProcessorNode=createNativeScriptProcessorNode(nativeContext,256,6,1),waveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,curve:new Float32Array([1,1]),oversample:"none"});let lastOrientation=[orientationX,orientationY,orientationZ],lastPosition=[positionX,positionY,positionZ];const buffer=new Float32Array(1);scriptProcessorNode.onaudioprocess=({inputBuffer})=>{const orientation=[getFirstSample(inputBuffer,buffer,0),getFirstSample(inputBuffer,buffer,1),getFirstSample(inputBuffer,buffer,2)];orientation.some((value,index)=>value!==lastOrientation[index])&&(pannerNode.setOrientation(...orientation),lastOrientation=orientation);const positon=[getFirstSample(inputBuffer,buffer,3),getFirstSample(inputBuffer,buffer,4),getFirstSample(inputBuffer,buffer,5)];positon.some((value,index)=>value!==lastPosition[index])&&(pannerNode.setPosition(...positon),lastPosition=positon)},Object.defineProperty(orientationYGainNode.gain,"defaultValue",{get:()=>0}),Object.defineProperty(orientationZGainNode.gain,"defaultValue",{get:()=>0}),Object.defineProperty(positionXGainNode.gain,"defaultValue",{get:()=>0}),Object.defineProperty(positionYGainNode.gain,"defaultValue",{get:()=>0}),Object.defineProperty(positionZGainNode.gain,"defaultValue",{get:()=>0});const nativePannerNodeFaker={get bufferSize(){},get channelCount(){return pannerNode.channelCount},set channelCount(value){if(value>2)throw createNotSupportedError();inputGainNode.channelCount=value,pannerNode.channelCount=value},get channelCountMode(){return pannerNode.channelCountMode},set channelCountMode(value){if("max"===value)throw createNotSupportedError();inputGainNode.channelCountMode=value,pannerNode.channelCountMode=value},get channelInterpretation(){return pannerNode.channelInterpretation},set channelInterpretation(value){inputGainNode.channelInterpretation=value,pannerNode.channelInterpretation=value},get coneInnerAngle(){return pannerNode.coneInnerAngle},set coneInnerAngle(value){pannerNode.coneInnerAngle=value},get coneOuterAngle(){return pannerNode.coneOuterAngle},set coneOuterAngle(value){pannerNode.coneOuterAngle=value},get coneOuterGain(){return pannerNode.coneOuterGain},set coneOuterGain(value){if(value<0||value>1)throw createInvalidStateError();pannerNode.coneOuterGain=value},get context(){return pannerNode.context},get distanceModel(){return pannerNode.distanceModel},set distanceModel(value){pannerNode.distanceModel=value},get inputs(){return[inputGainNode]},get maxDistance(){return pannerNode.maxDistance},set maxDistance(value){if(value<0)throw new RangeError;pannerNode.maxDistance=value},get numberOfInputs(){return pannerNode.numberOfInputs},get numberOfOutputs(){return pannerNode.numberOfOutputs},get orientationX(){return orientationXGainNode.gain},get orientationY(){return orientationYGainNode.gain},get orientationZ(){return orientationZGainNode.gain},get panningModel(){return pannerNode.panningModel},set panningModel(value){pannerNode.panningModel=value},get positionX(){return positionXGainNode.gain},get positionY(){return positionYGainNode.gain},get positionZ(){return positionZGainNode.gain},get refDistance(){return pannerNode.refDistance},set refDistance(value){if(value<0)throw new RangeError;pannerNode.refDistance=value},get rolloffFactor(){return pannerNode.rolloffFactor},set rolloffFactor(value){if(value<0)throw new RangeError;pannerNode.rolloffFactor=value},addEventListener:(...args)=>inputGainNode.addEventListener(args[0],args[1],args[2]),dispatchEvent:(...args)=>inputGainNode.dispatchEvent(args[0]),removeEventListener:(...args)=>inputGainNode.removeEventListener(args[0],args[1],args[2])};coneInnerAngle!==nativePannerNodeFaker.coneInnerAngle&&(nativePannerNodeFaker.coneInnerAngle=coneInnerAngle),coneOuterAngle!==nativePannerNodeFaker.coneOuterAngle&&(nativePannerNodeFaker.coneOuterAngle=coneOuterAngle),coneOuterGain!==nativePannerNodeFaker.coneOuterGain&&(nativePannerNodeFaker.coneOuterGain=coneOuterGain),distanceModel!==nativePannerNodeFaker.distanceModel&&(nativePannerNodeFaker.distanceModel=distanceModel),maxDistance!==nativePannerNodeFaker.maxDistance&&(nativePannerNodeFaker.maxDistance=maxDistance),orientationX!==nativePannerNodeFaker.orientationX.value&&(nativePannerNodeFaker.orientationX.value=orientationX),orientationY!==nativePannerNodeFaker.orientationY.value&&(nativePannerNodeFaker.orientationY.value=orientationY),orientationZ!==nativePannerNodeFaker.orientationZ.value&&(nativePannerNodeFaker.orientationZ.value=orientationZ),panningModel!==nativePannerNodeFaker.panningModel&&(nativePannerNodeFaker.panningModel=panningModel),positionX!==nativePannerNodeFaker.positionX.value&&(nativePannerNodeFaker.positionX.value=positionX),positionY!==nativePannerNodeFaker.positionY.value&&(nativePannerNodeFaker.positionY.value=positionY),positionZ!==nativePannerNodeFaker.positionZ.value&&(nativePannerNodeFaker.positionZ.value=positionZ),refDistance!==nativePannerNodeFaker.refDistance&&(nativePannerNodeFaker.refDistance=refDistance),rolloffFactor!==nativePannerNodeFaker.rolloffFactor&&(nativePannerNodeFaker.rolloffFactor=rolloffFactor),1===lastOrientation[0]&&0===lastOrientation[1]&&0===lastOrientation[2]||pannerNode.setOrientation(...lastOrientation),0===lastPosition[0]&&0===lastPosition[1]&&0===lastPosition[2]||pannerNode.setPosition(...lastPosition);return monitorConnections(interceptConnections(nativePannerNodeFaker,pannerNode),()=>{inputGainNode.connect(pannerNode),connectNativeAudioNodeToNativeAudioNode(inputGainNode,waveShaperNode,0,0),waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode,0,0),waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode,0,1),waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode,0,2),waveShaperNode.connect(positionXGainNode).connect(channelMergerNode,0,3),waveShaperNode.connect(positionYGainNode).connect(channelMergerNode,0,4),waveShaperNode.connect(positionZGainNode).connect(channelMergerNode,0,5),channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination)},()=>{inputGainNode.disconnect(pannerNode),disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode,waveShaperNode,0,0),waveShaperNode.disconnect(orientationXGainNode),orientationXGainNode.disconnect(channelMergerNode),waveShaperNode.disconnect(orientationYGainNode),orientationYGainNode.disconnect(channelMergerNode),waveShaperNode.disconnect(orientationZGainNode),orientationZGainNode.disconnect(channelMergerNode),waveShaperNode.disconnect(positionXGainNode),positionXGainNode.disconnect(channelMergerNode),waveShaperNode.disconnect(positionYGainNode),positionYGainNode.disconnect(channelMergerNode),waveShaperNode.disconnect(positionZGainNode),positionZGainNode.disconnect(channelMergerNode),channelMergerNode.disconnect(scriptProcessorNode),scriptProcessorNode.disconnect(nativeContext.destination)})})(connectNativeAudioNodeToNativeAudioNode,createInvalidStateError,createNativeChannelMergerNode,createNativeGainNode,createNativeScriptProcessorNode,createNativeWaveShaperNode,createNotSupportedError,disconnectNativeAudioNodeFromNativeAudioNode,getFirstSample,monitorConnections),createNativePannerNode=(createNativePannerNodeFaker=>(nativeContext,options)=>{const nativePannerNode=nativeContext.createPanner();return void 0===nativePannerNode.orientationX?createNativePannerNodeFaker(nativeContext,options):(assignNativeAudioNodeOptions(nativePannerNode,options),assignNativeAudioNodeAudioParamValue(nativePannerNode,options,"orientationX"),assignNativeAudioNodeAudioParamValue(nativePannerNode,options,"orientationY"),assignNativeAudioNodeAudioParamValue(nativePannerNode,options,"orientationZ"),assignNativeAudioNodeAudioParamValue(nativePannerNode,options,"positionX"),assignNativeAudioNodeAudioParamValue(nativePannerNode,options,"positionY"),assignNativeAudioNodeAudioParamValue(nativePannerNode,options,"positionZ"),assignNativeAudioNodeOption(nativePannerNode,options,"coneInnerAngle"),assignNativeAudioNodeOption(nativePannerNode,options,"coneOuterAngle"),assignNativeAudioNodeOption(nativePannerNode,options,"coneOuterGain"),assignNativeAudioNodeOption(nativePannerNode,options,"distanceModel"),assignNativeAudioNodeOption(nativePannerNode,options,"maxDistance"),assignNativeAudioNodeOption(nativePannerNode,options,"panningModel"),assignNativeAudioNodeOption(nativePannerNode,options,"refDistance"),assignNativeAudioNodeOption(nativePannerNode,options,"rolloffFactor"),nativePannerNode)})(createNativePannerNodeFaker),createPannerNodeRenderer=((connectAudioParam,createNativeChannelMergerNode,createNativeConstantSourceNode,createNativeGainNode,createNativePannerNode,getNativeAudioNode,nativeOfflineAudioContextConstructor,renderAutomation,renderInputsOfAudioNode,renderNativeOfflineAudioContext)=>()=>{const renderedNativeAudioNodes=new WeakMap;let renderedBufferPromise=null;return{render(proxy,nativeOfflineAudioContext){const renderedNativeGainNodeOrNativePannerNode=renderedNativeAudioNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeGainNodeOrNativePannerNode?Promise.resolve(renderedNativeGainNodeOrNativePannerNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeGainNode=null,nativePannerNode=getNativeAudioNode(proxy);const commonAudioNodeOptions={channelCount:nativePannerNode.channelCount,channelCountMode:nativePannerNode.channelCountMode,channelInterpretation:nativePannerNode.channelInterpretation},commonNativePannerNodeOptions={...commonAudioNodeOptions,coneInnerAngle:nativePannerNode.coneInnerAngle,coneOuterAngle:nativePannerNode.coneOuterAngle,coneOuterGain:nativePannerNode.coneOuterGain,distanceModel:nativePannerNode.distanceModel,maxDistance:nativePannerNode.maxDistance,panningModel:nativePannerNode.panningModel,refDistance:nativePannerNode.refDistance,rolloffFactor:nativePannerNode.rolloffFactor},nativePannerNodeIsOwnedByContext=isOwnedByContext(nativePannerNode,nativeOfflineAudioContext);if("bufferSize"in nativePannerNode)nativeGainNode=createNativeGainNode(nativeOfflineAudioContext,{...commonAudioNodeOptions,gain:1});else if(!nativePannerNodeIsOwnedByContext){const options={...commonNativePannerNodeOptions,orientationX:nativePannerNode.orientationX.value,orientationY:nativePannerNode.orientationY.value,orientationZ:nativePannerNode.orientationZ.value,positionX:nativePannerNode.positionX.value,positionY:nativePannerNode.positionY.value,positionZ:nativePannerNode.positionZ.value};nativePannerNode=createNativePannerNode(nativeOfflineAudioContext,options)}if(renderedNativeAudioNodes.set(nativeOfflineAudioContext,null===nativeGainNode?nativePannerNode:nativeGainNode),null!==nativeGainNode){if(null===renderedBufferPromise){if(null===nativeOfflineAudioContextConstructor)throw new Error("Missing the native OfflineAudioContext constructor.");const partialOfflineAudioContext=new nativeOfflineAudioContextConstructor(6,proxy.context.length,nativeOfflineAudioContext.sampleRate),nativeChannelMergerNode=createNativeChannelMergerNode(partialOfflineAudioContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:6});nativeChannelMergerNode.connect(partialOfflineAudioContext.destination),renderedBufferPromise=(async()=>{const nativeConstantSourceNodes=await Promise.all([proxy.orientationX,proxy.orientationY,proxy.orientationZ,proxy.positionX,proxy.positionY,proxy.positionZ].map(async(audioParam,index)=>{const nativeConstantSourceNode=createNativeConstantSourceNode(partialOfflineAudioContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:0===index?1:0});return await renderAutomation(partialOfflineAudioContext,audioParam,nativeConstantSourceNode.offset),nativeConstantSourceNode}));for(let i=0;i<6;i+=1)nativeConstantSourceNodes[i].connect(nativeChannelMergerNode,0,i),nativeConstantSourceNodes[i].start(0);return renderNativeOfflineAudioContext(partialOfflineAudioContext)})()}const renderedBuffer=await renderedBufferPromise,inputGainNode=createNativeGainNode(nativeOfflineAudioContext,{...commonAudioNodeOptions,gain:1});await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,inputGainNode);const channelDatas=[];for(let i=0;i<renderedBuffer.numberOfChannels;i+=1)channelDatas.push(renderedBuffer.getChannelData(i));let lastOrientation=[channelDatas[0][0],channelDatas[1][0],channelDatas[2][0]],lastPosition=[channelDatas[3][0],channelDatas[4][0],channelDatas[5][0]],gateGainNode=createNativeGainNode(nativeOfflineAudioContext,{...commonAudioNodeOptions,gain:1}),partialPannerNode=createNativePannerNode(nativeOfflineAudioContext,{...commonNativePannerNodeOptions,orientationX:lastOrientation[0],orientationY:lastOrientation[1],orientationZ:lastOrientation[2],positionX:lastPosition[0],positionY:lastPosition[1],positionZ:lastPosition[2]});inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]),partialPannerNode.connect(nativeGainNode);for(let i=128;i<renderedBuffer.length;i+=128){const orientation=[channelDatas[0][i],channelDatas[1][i],channelDatas[2][i]],positon=[channelDatas[3][i],channelDatas[4][i],channelDatas[5][i]];if(orientation.some((value,index)=>value!==lastOrientation[index])||positon.some((value,index)=>value!==lastPosition[index])){lastOrientation=orientation,lastPosition=positon;const currentTime=i/nativeOfflineAudioContext.sampleRate;gateGainNode.gain.setValueAtTime(0,currentTime),gateGainNode=createNativeGainNode(nativeOfflineAudioContext,{...commonAudioNodeOptions,gain:0}),partialPannerNode=createNativePannerNode(nativeOfflineAudioContext,{...commonNativePannerNodeOptions,orientationX:lastOrientation[0],orientationY:lastOrientation[1],orientationZ:lastOrientation[2],positionX:lastPosition[0],positionY:lastPosition[1],positionZ:lastPosition[2]}),gateGainNode.gain.setValueAtTime(1,currentTime),inputGainNode.connect(gateGainNode).connect(partialPannerNode.inputs[0]),partialPannerNode.connect(nativeGainNode)}}return nativeGainNode}return nativePannerNodeIsOwnedByContext?(await connectAudioParam(nativeOfflineAudioContext,proxy.orientationX,nativePannerNode.orientationX),await connectAudioParam(nativeOfflineAudioContext,proxy.orientationY,nativePannerNode.orientationY),await connectAudioParam(nativeOfflineAudioContext,proxy.orientationZ,nativePannerNode.orientationZ),await connectAudioParam(nativeOfflineAudioContext,proxy.positionX,nativePannerNode.positionX),await connectAudioParam(nativeOfflineAudioContext,proxy.positionY,nativePannerNode.positionY),await connectAudioParam(nativeOfflineAudioContext,proxy.positionZ,nativePannerNode.positionZ)):(await renderAutomation(nativeOfflineAudioContext,proxy.orientationX,nativePannerNode.orientationX),await renderAutomation(nativeOfflineAudioContext,proxy.orientationY,nativePannerNode.orientationY),await renderAutomation(nativeOfflineAudioContext,proxy.orientationZ,nativePannerNode.orientationZ),await renderAutomation(nativeOfflineAudioContext,proxy.positionX,nativePannerNode.positionX),await renderAutomation(nativeOfflineAudioContext,proxy.positionY,nativePannerNode.positionY),await renderAutomation(nativeOfflineAudioContext,proxy.positionZ,nativePannerNode.positionZ)),isNativeAudioNodeFaker(nativePannerNode)?await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativePannerNode.inputs[0]):await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativePannerNode),nativePannerNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeChannelMergerNode,createNativeConstantSourceNode,createNativeGainNode,createNativePannerNode,getNativeAudioNode,nativeOfflineAudioContextConstructor,renderAutomation,renderInputsOfAudioNode,renderNativeOfflineAudioContext),pannerNodeConstructor=((audioNodeConstructor,createAudioParam,createNativePannerNode,createPannerNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime)=>class PannerNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...panner_node_constructor_DEFAULT_OPTIONS,...options},nativePannerNode=createNativePannerNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext);super(context,!1,nativePannerNode,isOffline?createPannerNodeRenderer():null),this._nativePannerNode=nativePannerNode,this._orientationX=createAudioParam(this,isOffline,nativePannerNode.orientationX,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._orientationY=createAudioParam(this,isOffline,nativePannerNode.orientationY,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._orientationZ=createAudioParam(this,isOffline,nativePannerNode.orientationZ,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionX=createAudioParam(this,isOffline,nativePannerNode.positionX,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionY=createAudioParam(this,isOffline,nativePannerNode.positionY,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),this._positionZ=createAudioParam(this,isOffline,nativePannerNode.positionZ,MOST_POSITIVE_SINGLE_FLOAT,MOST_NEGATIVE_SINGLE_FLOAT),setAudioNodeTailTime(this,1)}get coneInnerAngle(){return this._nativePannerNode.coneInnerAngle}set coneInnerAngle(value){this._nativePannerNode.coneInnerAngle=value}get coneOuterAngle(){return this._nativePannerNode.coneOuterAngle}set coneOuterAngle(value){this._nativePannerNode.coneOuterAngle=value}get coneOuterGain(){return this._nativePannerNode.coneOuterGain}set coneOuterGain(value){this._nativePannerNode.coneOuterGain=value}get distanceModel(){return this._nativePannerNode.distanceModel}set distanceModel(value){this._nativePannerNode.distanceModel=value}get maxDistance(){return this._nativePannerNode.maxDistance}set maxDistance(value){this._nativePannerNode.maxDistance=value}get orientationX(){return this._orientationX}get orientationY(){return this._orientationY}get orientationZ(){return this._orientationZ}get panningModel(){return this._nativePannerNode.panningModel}set panningModel(value){this._nativePannerNode.panningModel=value}get positionX(){return this._positionX}get positionY(){return this._positionY}get positionZ(){return this._positionZ}get refDistance(){return this._nativePannerNode.refDistance}set refDistance(value){this._nativePannerNode.refDistance=value}get rolloffFactor(){return this._nativePannerNode.rolloffFactor}set rolloffFactor(value){this._nativePannerNode.rolloffFactor=value}})(audioNodeConstructor,createAudioParam,createNativePannerNode,createPannerNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),createNativePeriodicWave=(createIndexSizeError=>(nativeContext,{disableNormalization,imag,real})=>{const convertedImag=imag instanceof Float32Array?imag:new Float32Array(imag),convertedReal=real instanceof Float32Array?real:new Float32Array(real),nativePeriodicWave=nativeContext.createPeriodicWave(convertedReal,convertedImag,{disableNormalization});if(Array.from(imag).length<2)throw createIndexSizeError();return nativePeriodicWave})(createIndexSizeError),periodicWaveConstructor=((createNativePeriodicWave,getNativeContext,periodicWaveStore,sanitizePeriodicWaveOptions)=>class PeriodicWave{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions=sanitizePeriodicWaveOptions({...periodic_wave_constructor_DEFAULT_OPTIONS,...options}),periodicWave=createNativePeriodicWave(nativeContext,mergedOptions);return periodicWaveStore.add(periodicWave),periodicWave}static[Symbol.hasInstance](instance){return null!==instance&&"object"==typeof instance&&Object.getPrototypeOf(instance)===PeriodicWave.prototype||periodicWaveStore.has(instance)}})(createNativePeriodicWave,getNativeContext,new WeakSet,options=>{const{imag,real}=options;return void 0===imag?void 0===real?{...options,imag:[0,0],real:[0,0]}:{...options,imag:Array.from(real,()=>0),real}:void 0===real?{...options,imag,real:Array.from(imag,()=>0)}:{...options,imag,real}}),nativeStereoPannerNodeFakerFactory=((createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeGainNode,createNativeWaveShaperNode,createNotSupportedError,monitorConnections)=>{const DC_CURVE=new Float32Array([1,1]),HALF_PI=Math.PI/2,SINGLE_CHANNEL_OPTIONS={channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete"},SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS={...SINGLE_CHANNEL_OPTIONS,oversample:"none"},buildInternalGraph=(nativeContext,channelCount,inputGainNode,panGainNode,channelMergerNode)=>{if(1===channelCount)return((nativeContext,inputGainNode,panGainNode,channelMergerNode)=>{const leftWaveShaperCurve=new Float32Array(16385),rightWaveShaperCurve=new Float32Array(16385);for(let i=0;i<16385;i+=1){const x=i/16384*HALF_PI;leftWaveShaperCurve[i]=Math.cos(x),rightWaveShaperCurve[i]=Math.sin(x)}const leftGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),leftWaveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,curve:leftWaveShaperCurve}),panWaveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,curve:DC_CURVE}),rightGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),rightWaveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,curve:rightWaveShaperCurve});return{connectGraph(){inputGainNode.connect(leftGainNode),inputGainNode.connect(void 0===panWaveShaperNode.inputs?panWaveShaperNode:panWaveShaperNode.inputs[0]),inputGainNode.connect(rightGainNode),panWaveShaperNode.connect(panGainNode),panGainNode.connect(void 0===leftWaveShaperNode.inputs?leftWaveShaperNode:leftWaveShaperNode.inputs[0]),panGainNode.connect(void 0===rightWaveShaperNode.inputs?rightWaveShaperNode:rightWaveShaperNode.inputs[0]),leftWaveShaperNode.connect(leftGainNode.gain),rightWaveShaperNode.connect(rightGainNode.gain),leftGainNode.connect(channelMergerNode,0,0),rightGainNode.connect(channelMergerNode,0,1)},disconnectGraph(){inputGainNode.disconnect(leftGainNode),inputGainNode.disconnect(void 0===panWaveShaperNode.inputs?panWaveShaperNode:panWaveShaperNode.inputs[0]),inputGainNode.disconnect(rightGainNode),panWaveShaperNode.disconnect(panGainNode),panGainNode.disconnect(void 0===leftWaveShaperNode.inputs?leftWaveShaperNode:leftWaveShaperNode.inputs[0]),panGainNode.disconnect(void 0===rightWaveShaperNode.inputs?rightWaveShaperNode:rightWaveShaperNode.inputs[0]),leftWaveShaperNode.disconnect(leftGainNode.gain),rightWaveShaperNode.disconnect(rightGainNode.gain),leftGainNode.disconnect(channelMergerNode,0,0),rightGainNode.disconnect(channelMergerNode,0,1)}}})(nativeContext,inputGainNode,panGainNode,channelMergerNode);if(2===channelCount)return((nativeContext,inputGainNode,panGainNode,channelMergerNode)=>{const leftInputForLeftOutputWaveShaperCurve=new Float32Array(16385),leftInputForRightOutputWaveShaperCurve=new Float32Array(16385),rightInputForLeftOutputWaveShaperCurve=new Float32Array(16385),rightInputForRightOutputWaveShaperCurve=new Float32Array(16385),centerIndex=Math.floor(8192.5);for(let i=0;i<16385;i+=1)if(i>centerIndex){const x=(i-centerIndex)/(16384-centerIndex)*HALF_PI;leftInputForLeftOutputWaveShaperCurve[i]=Math.cos(x),leftInputForRightOutputWaveShaperCurve[i]=Math.sin(x),rightInputForLeftOutputWaveShaperCurve[i]=0,rightInputForRightOutputWaveShaperCurve[i]=1}else{const x=i/(16384-centerIndex)*HALF_PI;leftInputForLeftOutputWaveShaperCurve[i]=1,leftInputForRightOutputWaveShaperCurve[i]=0,rightInputForLeftOutputWaveShaperCurve[i]=Math.cos(x),rightInputForRightOutputWaveShaperCurve[i]=Math.sin(x)}const channelSplitterNode=createNativeChannelSplitterNode(nativeContext,{channelCount:2,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:2}),leftInputForLeftOutputGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),leftInputForLeftOutputWaveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,curve:leftInputForLeftOutputWaveShaperCurve}),leftInputForRightOutputGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),leftInputForRightOutputWaveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,curve:leftInputForRightOutputWaveShaperCurve}),panWaveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,curve:DC_CURVE}),rightInputForLeftOutputGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),rightInputForLeftOutputWaveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,curve:rightInputForLeftOutputWaveShaperCurve}),rightInputForRightOutputGainNode=createNativeGainNode(nativeContext,{...SINGLE_CHANNEL_OPTIONS,gain:0}),rightInputForRightOutputWaveShaperNode=createNativeWaveShaperNode(nativeContext,{...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,curve:rightInputForRightOutputWaveShaperCurve});return{connectGraph(){inputGainNode.connect(channelSplitterNode),inputGainNode.connect(void 0===panWaveShaperNode.inputs?panWaveShaperNode:panWaveShaperNode.inputs[0]),channelSplitterNode.connect(leftInputForLeftOutputGainNode,0),channelSplitterNode.connect(leftInputForRightOutputGainNode,0),channelSplitterNode.connect(rightInputForLeftOutputGainNode,1),channelSplitterNode.connect(rightInputForRightOutputGainNode,1),panWaveShaperNode.connect(panGainNode),panGainNode.connect(void 0===leftInputForLeftOutputWaveShaperNode.inputs?leftInputForLeftOutputWaveShaperNode:leftInputForLeftOutputWaveShaperNode.inputs[0]),panGainNode.connect(void 0===leftInputForRightOutputWaveShaperNode.inputs?leftInputForRightOutputWaveShaperNode:leftInputForRightOutputWaveShaperNode.inputs[0]),panGainNode.connect(void 0===rightInputForLeftOutputWaveShaperNode.inputs?rightInputForLeftOutputWaveShaperNode:rightInputForLeftOutputWaveShaperNode.inputs[0]),panGainNode.connect(void 0===rightInputForRightOutputWaveShaperNode.inputs?rightInputForRightOutputWaveShaperNode:rightInputForRightOutputWaveShaperNode.inputs[0]),leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain),leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain),rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain),rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain),leftInputForLeftOutputGainNode.connect(channelMergerNode,0,0),rightInputForLeftOutputGainNode.connect(channelMergerNode,0,0),leftInputForRightOutputGainNode.connect(channelMergerNode,0,1),rightInputForRightOutputGainNode.connect(channelMergerNode,0,1)},disconnectGraph(){inputGainNode.disconnect(channelSplitterNode),inputGainNode.disconnect(void 0===panWaveShaperNode.inputs?panWaveShaperNode:panWaveShaperNode.inputs[0]),channelSplitterNode.disconnect(leftInputForLeftOutputGainNode,0),channelSplitterNode.disconnect(leftInputForRightOutputGainNode,0),channelSplitterNode.disconnect(rightInputForLeftOutputGainNode,1),channelSplitterNode.disconnect(rightInputForRightOutputGainNode,1),panWaveShaperNode.disconnect(panGainNode),panGainNode.disconnect(void 0===leftInputForLeftOutputWaveShaperNode.inputs?leftInputForLeftOutputWaveShaperNode:leftInputForLeftOutputWaveShaperNode.inputs[0]),panGainNode.disconnect(void 0===leftInputForRightOutputWaveShaperNode.inputs?leftInputForRightOutputWaveShaperNode:leftInputForRightOutputWaveShaperNode.inputs[0]),panGainNode.disconnect(void 0===rightInputForLeftOutputWaveShaperNode.inputs?rightInputForLeftOutputWaveShaperNode:rightInputForLeftOutputWaveShaperNode.inputs[0]),panGainNode.disconnect(void 0===rightInputForRightOutputWaveShaperNode.inputs?rightInputForRightOutputWaveShaperNode:rightInputForRightOutputWaveShaperNode.inputs[0]),leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain),leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain),rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain),rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain),leftInputForLeftOutputGainNode.disconnect(channelMergerNode,0,0),rightInputForLeftOutputGainNode.disconnect(channelMergerNode,0,0),leftInputForRightOutputGainNode.disconnect(channelMergerNode,0,1),rightInputForRightOutputGainNode.disconnect(channelMergerNode,0,1)}}})(nativeContext,inputGainNode,panGainNode,channelMergerNode);throw createNotSupportedError()};return(nativeContext,{channelCount,channelCountMode,pan,...audioNodeOptions})=>{if("max"===channelCountMode)throw createNotSupportedError();const channelMergerNode=createNativeChannelMergerNode(nativeContext,{...audioNodeOptions,channelCount:1,channelCountMode,numberOfInputs:2}),inputGainNode=createNativeGainNode(nativeContext,{...audioNodeOptions,channelCount,channelCountMode,gain:1}),panGainNode=createNativeGainNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:pan});let{connectGraph,disconnectGraph}=buildInternalGraph(nativeContext,channelCount,inputGainNode,panGainNode,channelMergerNode);Object.defineProperty(panGainNode.gain,"defaultValue",{get:()=>0}),Object.defineProperty(panGainNode.gain,"maxValue",{get:()=>1}),Object.defineProperty(panGainNode.gain,"minValue",{get:()=>-1});const nativeStereoPannerNodeFakerFactory={get bufferSize(){},get channelCount(){return inputGainNode.channelCount},set channelCount(value){inputGainNode.channelCount!==value&&(isConnected&&disconnectGraph(),({connectGraph,disconnectGraph}=buildInternalGraph(nativeContext,value,inputGainNode,panGainNode,channelMergerNode)),isConnected&&connectGraph()),inputGainNode.channelCount=value},get channelCountMode(){return inputGainNode.channelCountMode},set channelCountMode(value){if("clamped-max"===value||"max"===value)throw createNotSupportedError();inputGainNode.channelCountMode=value},get channelInterpretation(){return inputGainNode.channelInterpretation},set channelInterpretation(value){inputGainNode.channelInterpretation=value},get context(){return inputGainNode.context},get inputs(){return[inputGainNode]},get numberOfInputs(){return inputGainNode.numberOfInputs},get numberOfOutputs(){return inputGainNode.numberOfOutputs},get pan(){return panGainNode.gain},addEventListener:(...args)=>inputGainNode.addEventListener(args[0],args[1],args[2]),dispatchEvent:(...args)=>inputGainNode.dispatchEvent(args[0]),removeEventListener:(...args)=>inputGainNode.removeEventListener(args[0],args[1],args[2])};let isConnected=!1;return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory,channelMergerNode),()=>{connectGraph(),isConnected=!0},()=>{disconnectGraph(),isConnected=!1})}})(createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeGainNode,createNativeWaveShaperNode,createNotSupportedError,monitorConnections),createNativeStereoPannerNode=((createNativeStereoPannerNodeFaker,createNotSupportedError)=>(nativeContext,options)=>{const channelCountMode=options.channelCountMode;if("clamped-max"===channelCountMode)throw createNotSupportedError();if(void 0===nativeContext.createStereoPanner)return createNativeStereoPannerNodeFaker(nativeContext,options);const nativeStereoPannerNode=nativeContext.createStereoPanner();return assignNativeAudioNodeOptions(nativeStereoPannerNode,options),assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode,options,"pan"),Object.defineProperty(nativeStereoPannerNode,"channelCountMode",{get:()=>channelCountMode,set:value=>{if(value!==channelCountMode)throw createNotSupportedError()}}),nativeStereoPannerNode})(nativeStereoPannerNodeFakerFactory,createNotSupportedError),createStereoPannerNodeRenderer=((connectAudioParam,createNativeStereoPannerNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode)=>()=>{const renderedNativeStereoPannerNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeStereoPannerNode=renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeStereoPannerNode?Promise.resolve(renderedNativeStereoPannerNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeStereoPannerNode=getNativeAudioNode(proxy);const nativeStereoPannerNodeIsOwnedByContext=isOwnedByContext(nativeStereoPannerNode,nativeOfflineAudioContext);if(!nativeStereoPannerNodeIsOwnedByContext){const options={channelCount:nativeStereoPannerNode.channelCount,channelCountMode:nativeStereoPannerNode.channelCountMode,channelInterpretation:nativeStereoPannerNode.channelInterpretation,pan:nativeStereoPannerNode.pan.value};nativeStereoPannerNode=createNativeStereoPannerNode(nativeOfflineAudioContext,options)}return renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext,nativeStereoPannerNode),nativeStereoPannerNodeIsOwnedByContext?await connectAudioParam(nativeOfflineAudioContext,proxy.pan,nativeStereoPannerNode.pan):await renderAutomation(nativeOfflineAudioContext,proxy.pan,nativeStereoPannerNode.pan),isNativeAudioNodeFaker(nativeStereoPannerNode)?await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeStereoPannerNode.inputs[0]):await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeStereoPannerNode),nativeStereoPannerNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,createNativeStereoPannerNode,getNativeAudioNode,renderAutomation,renderInputsOfAudioNode),stereoPannerNodeConstructor=((audioNodeConstructor,createAudioParam,createNativeStereoPannerNode,createStereoPannerNodeRenderer,getNativeContext,isNativeOfflineAudioContext)=>class StereoPannerNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...stereo_panner_node_constructor_DEFAULT_OPTIONS,...options},nativeStereoPannerNode=createNativeStereoPannerNode(nativeContext,mergedOptions),isOffline=isNativeOfflineAudioContext(nativeContext);super(context,!1,nativeStereoPannerNode,isOffline?createStereoPannerNodeRenderer():null),this._pan=createAudioParam(this,isOffline,nativeStereoPannerNode.pan)}get pan(){return this._pan}})(audioNodeConstructor,createAudioParam,createNativeStereoPannerNode,createStereoPannerNodeRenderer,getNativeContext,isNativeOfflineAudioContext),createWaveShaperNodeRenderer=((createNativeWaveShaperNode,getNativeAudioNode,renderInputsOfAudioNode)=>()=>{const renderedNativeWaveShaperNodes=new WeakMap;return{render(proxy,nativeOfflineAudioContext){const renderedNativeWaveShaperNode=renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeWaveShaperNode?Promise.resolve(renderedNativeWaveShaperNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeWaveShaperNode=getNativeAudioNode(proxy);if(!isOwnedByContext(nativeWaveShaperNode,nativeOfflineAudioContext)){const options={channelCount:nativeWaveShaperNode.channelCount,channelCountMode:nativeWaveShaperNode.channelCountMode,channelInterpretation:nativeWaveShaperNode.channelInterpretation,curve:nativeWaveShaperNode.curve,oversample:nativeWaveShaperNode.oversample};nativeWaveShaperNode=createNativeWaveShaperNode(nativeOfflineAudioContext,options)}return renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext,nativeWaveShaperNode),isNativeAudioNodeFaker(nativeWaveShaperNode)?await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeWaveShaperNode.inputs[0]):await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeWaveShaperNode),nativeWaveShaperNode})(proxy,nativeOfflineAudioContext)}}})(createNativeWaveShaperNode,getNativeAudioNode,renderInputsOfAudioNode),waveShaperNodeConstructor=((audioNodeConstructor,createInvalidStateError,createNativeWaveShaperNode,createWaveShaperNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime)=>class WaveShaperNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),mergedOptions={...wave_shaper_node_constructor_DEFAULT_OPTIONS,...options},nativeWaveShaperNode=createNativeWaveShaperNode(nativeContext,mergedOptions);super(context,!0,nativeWaveShaperNode,isNativeOfflineAudioContext(nativeContext)?createWaveShaperNodeRenderer():null),this._isCurveNullified=!1,this._nativeWaveShaperNode=nativeWaveShaperNode,setAudioNodeTailTime(this,1)}get curve(){return this._isCurveNullified?null:this._nativeWaveShaperNode.curve}set curve(value){if(null===value)this._isCurveNullified=!0,this._nativeWaveShaperNode.curve=new Float32Array([0,0]);else{if(value.length<2)throw createInvalidStateError();this._isCurveNullified=!1,this._nativeWaveShaperNode.curve=value}}get oversample(){return this._nativeWaveShaperNode.oversample}set oversample(value){this._nativeWaveShaperNode.oversample=value}})(audioNodeConstructor,createInvalidStateError,createNativeWaveShaperNode,createWaveShaperNodeRenderer,getNativeContext,isNativeOfflineAudioContext,setAudioNodeTailTime),isSecureContext=(window=>null!==window&&window.isSecureContext)(module_window),exposeCurrentFrameAndCurrentTime=(window=>(currentTime,sampleRate,fn)=>{Object.defineProperties(window,{currentFrame:{configurable:!0,get:()=>Math.round(currentTime*sampleRate)},currentTime:{configurable:!0,get:()=>currentTime}});try{return fn()}finally{null!==window&&(delete window.currentFrame,delete window.currentTime)}})(module_window),backupOfflineAudioContextStore=new WeakMap,getOrCreateBackupOfflineAudioContext=((backupOfflineAudioContextStore,nativeOfflineAudioContextConstructor)=>nativeContext=>{let backupOfflineAudioContext=backupOfflineAudioContextStore.get(nativeContext);if(void 0!==backupOfflineAudioContext)return backupOfflineAudioContext;if(null===nativeOfflineAudioContextConstructor)throw new Error("Missing the native OfflineAudioContext constructor.");return backupOfflineAudioContext=new nativeOfflineAudioContextConstructor(1,1,44100),backupOfflineAudioContextStore.set(nativeContext,backupOfflineAudioContext),backupOfflineAudioContext})(backupOfflineAudioContextStore,nativeOfflineAudioContextConstructor),addAudioWorkletModule=isSecureContext?((cacheTestResult,createNotSupportedError,evaluateSource,exposeCurrentFrameAndCurrentTime,fetchSource,getNativeContext,getOrCreateBackupOfflineAudioContext,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor,ongoingRequests,resolvedRequests,testAudioWorkletProcessorPostMessageSupport,window)=>{let index=0;return(context,moduleURL,options={credentials:"omit"})=>{const resolvedRequestsOfContext=resolvedRequests.get(context);if(void 0!==resolvedRequestsOfContext&&resolvedRequestsOfContext.has(moduleURL))return Promise.resolve();const ongoingRequestsOfContext=ongoingRequests.get(context);if(void 0!==ongoingRequestsOfContext){const promiseOfOngoingRequest=ongoingRequestsOfContext.get(moduleURL);if(void 0!==promiseOfOngoingRequest)return promiseOfOngoingRequest}const nativeContext=getNativeContext(context),promise=void 0===nativeContext.audioWorklet?fetchSource(moduleURL).then(([source,absoluteUrl])=>{const[importStatements,sourceWithoutImportStatements]=splitImportStatements(source,absoluteUrl);return evaluateSource(`${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`)}).then(()=>{const evaluateAudioWorkletGlobalScope=window._AWGS.pop();if(void 0===evaluateAudioWorkletGlobalScope)throw new SyntaxError;exposeCurrentFrameAndCurrentTime(nativeContext.currentTime,nativeContext.sampleRate,()=>evaluateAudioWorkletGlobalScope(class AudioWorkletProcessor{},void 0,(name,processorCtor)=>{if(""===name.trim())throw createNotSupportedError();const nodeNameToProcessorConstructorMap=NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);if(void 0!==nodeNameToProcessorConstructorMap){if(nodeNameToProcessorConstructorMap.has(name))throw createNotSupportedError();verifyProcessorCtor(processorCtor),verifyParameterDescriptors(processorCtor.parameterDescriptors),nodeNameToProcessorConstructorMap.set(name,processorCtor)}else verifyProcessorCtor(processorCtor),verifyParameterDescriptors(processorCtor.parameterDescriptors),NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext,new Map([[name,processorCtor]]))},nativeContext.sampleRate,void 0,void 0))}):Promise.all([fetchSource(moduleURL),Promise.resolve(cacheTestResult(testAudioWorkletProcessorPostMessageSupport,testAudioWorkletProcessorPostMessageSupport))]).then(([[source,absoluteUrl],isSupportingPostMessage])=>{const currentIndex=index+1;index=currentIndex;const[importStatements,sourceWithoutImportStatements]=splitImportStatements(source,absoluteUrl),blob=new Blob([`${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${isSupportingPostMessage?"AudioWorkletProcessor":"class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}"},(n,p)=>registerProcessor(n,class extends p{${isSupportingPostMessage?"":"__c = (a) => a.forEach(e=>this.__b.add(e.buffer));"}process(i,o,p){${isSupportingPostMessage?"":"i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));"}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`],{type:"application/javascript; charset=utf-8"}),url=URL.createObjectURL(blob);return nativeContext.audioWorklet.addModule(url,options).then(()=>{if(isNativeOfflineAudioContext(nativeContext))return nativeContext;const backupOfflineAudioContext=getOrCreateBackupOfflineAudioContext(nativeContext);return backupOfflineAudioContext.audioWorklet.addModule(url,options).then(()=>backupOfflineAudioContext)}).then(nativeContextOrBackupOfflineAudioContext=>{if(null===nativeAudioWorkletNodeConstructor)throw new SyntaxError;try{new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext,`__sac${currentIndex}`)}catch{throw new SyntaxError}}).finally(()=>URL.revokeObjectURL(url))});return void 0===ongoingRequestsOfContext?ongoingRequests.set(context,new Map([[moduleURL,promise]])):ongoingRequestsOfContext.set(moduleURL,promise),promise.then(()=>{const updatedResolvedRequestsOfContext=resolvedRequests.get(context);void 0===updatedResolvedRequestsOfContext?resolvedRequests.set(context,new Set([moduleURL])):updatedResolvedRequestsOfContext.add(moduleURL)}).finally(()=>{const updatedOngoingRequestsOfContext=ongoingRequests.get(context);void 0!==updatedOngoingRequestsOfContext&&updatedOngoingRequestsOfContext.delete(moduleURL)}),promise}})(cacheTestResult,createNotSupportedError,(window=>source=>new Promise((resolve,reject)=>{if(null===window)return void reject(new SyntaxError);const head=window.document.head;if(null===head)reject(new SyntaxError);else{const script=window.document.createElement("script"),blob=new Blob([source],{type:"application/javascript"}),url=URL.createObjectURL(blob),originalOnErrorHandler=window.onerror,removeErrorEventListenerAndRevokeUrl=()=>{window.onerror=originalOnErrorHandler,URL.revokeObjectURL(url)};window.onerror=(message,src,lineno,colno,error)=>src===url||src===window.location.href&&1===lineno&&1===colno?(removeErrorEventListenerAndRevokeUrl(),reject(error),!1):null!==originalOnErrorHandler?originalOnErrorHandler(message,src,lineno,colno,error):void 0,script.onerror=()=>{removeErrorEventListenerAndRevokeUrl(),reject(new SyntaxError)},script.onload=()=>{removeErrorEventListenerAndRevokeUrl(),resolve()},script.src=url,script.type="module",head.appendChild(script)}}))(module_window),exposeCurrentFrameAndCurrentTime,(createAbortError=>async url=>{try{const response=await fetch(url);if(response.ok)return[await response.text(),response.url]}catch{}throw createAbortError()})(()=>new DOMException("","AbortError")),getNativeContext,getOrCreateBackupOfflineAudioContext,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor,new WeakMap,new WeakMap,((nativeAudioWorkletNodeConstructor,nativeOfflineAudioContextConstructor)=>async()=>{if(null===nativeAudioWorkletNodeConstructor)return!0;if(null===nativeOfflineAudioContextConstructor)return!1;const blob=new Blob(['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor("a",A)'],{type:"application/javascript; charset=utf-8"}),offlineAudioContext=new nativeOfflineAudioContextConstructor(1,128,44100),url=URL.createObjectURL(blob);let isEmittingMessageEvents=!1,isEmittingProcessorErrorEvents=!1;try{await offlineAudioContext.audioWorklet.addModule(url);const audioWorkletNode=new nativeAudioWorkletNodeConstructor(offlineAudioContext,"a",{numberOfOutputs:0}),oscillator=offlineAudioContext.createOscillator();audioWorkletNode.port.onmessage=()=>isEmittingMessageEvents=!0,audioWorkletNode.onprocessorerror=()=>isEmittingProcessorErrorEvents=!0,oscillator.connect(audioWorkletNode),oscillator.start(0),await offlineAudioContext.startRendering()}catch{}finally{URL.revokeObjectURL(url)}return isEmittingMessageEvents&&!isEmittingProcessorErrorEvents})(nativeAudioWorkletNodeConstructor,nativeOfflineAudioContextConstructor),module_window):void 0,isNativeContext=((isNativeAudioContext,isNativeOfflineAudioContext)=>anything=>isNativeAudioContext(anything)||isNativeOfflineAudioContext(anything))(isNativeAudioContext,isNativeOfflineAudioContext),decodeAudioData=((audioBufferStore,cacheTestResult,createDataCloneError,createEncodingError,detachedArrayBuffers,getNativeContext,isNativeContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,testPromiseSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds)=>(anyContext,audioData)=>{const nativeContext=isNativeContext(anyContext)?anyContext:getNativeContext(anyContext);if(detachedArrayBuffers.has(audioData)){const err=createDataCloneError();return Promise.reject(err)}try{detachedArrayBuffers.add(audioData)}catch{}return cacheTestResult(testPromiseSupport,()=>testPromiseSupport(nativeContext))?nativeContext.decodeAudioData(audioData).then(audioBuffer=>(detachArrayBuffer(audioData).catch(()=>{}),cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport,()=>testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))||wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer),audioBufferStore.add(audioBuffer),audioBuffer)):new Promise((resolve,reject)=>{const complete=async()=>{try{await detachArrayBuffer(audioData)}catch{}},fail=err=>{reject(err),complete()};try{nativeContext.decodeAudioData(audioData,audioBuffer=>{"function"!=typeof audioBuffer.copyFromChannel&&(wrapAudioBufferCopyChannelMethods(audioBuffer),wrapAudioBufferGetChannelDataMethod(audioBuffer)),audioBufferStore.add(audioBuffer),complete().then(()=>resolve(audioBuffer))},err=>{fail(null===err?createEncodingError():err)})}catch(err){fail(err)}})})(audioBufferStore,cacheTestResult,()=>new DOMException("","DataCloneError"),()=>new DOMException("","EncodingError"),new WeakSet,getNativeContext,isNativeContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,testPromiseSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds),baseAudioContextConstructor=((addAudioWorkletModule,analyserNodeConstructor,audioBufferConstructor,audioBufferSourceNodeConstructor,biquadFilterNodeConstructor,channelMergerNodeConstructor,channelSplitterNodeConstructor,constantSourceNodeConstructor,convolverNodeConstructor,decodeAudioData,delayNodeConstructor,dynamicsCompressorNodeConstructor,gainNodeConstructor,iIRFilterNodeConstructor,minimalBaseAudioContextConstructor,oscillatorNodeConstructor,pannerNodeConstructor,periodicWaveConstructor,stereoPannerNodeConstructor,waveShaperNodeConstructor)=>class BaseAudioContext extends minimalBaseAudioContextConstructor{constructor(_nativeContext,numberOfChannels){super(_nativeContext,numberOfChannels),this._nativeContext=_nativeContext,this._audioWorklet=void 0===addAudioWorkletModule?void 0:{addModule:(moduleURL,options)=>addAudioWorkletModule(this,moduleURL,options)}}get audioWorklet(){return this._audioWorklet}createAnalyser(){return new analyserNodeConstructor(this)}createBiquadFilter(){return new biquadFilterNodeConstructor(this)}createBuffer(numberOfChannels,length,sampleRate){return new audioBufferConstructor({length,numberOfChannels,sampleRate})}createBufferSource(){return new audioBufferSourceNodeConstructor(this)}createChannelMerger(numberOfInputs=6){return new channelMergerNodeConstructor(this,{numberOfInputs})}createChannelSplitter(numberOfOutputs=6){return new channelSplitterNodeConstructor(this,{numberOfOutputs})}createConstantSource(){return new constantSourceNodeConstructor(this)}createConvolver(){return new convolverNodeConstructor(this)}createDelay(maxDelayTime=1){return new delayNodeConstructor(this,{maxDelayTime})}createDynamicsCompressor(){return new dynamicsCompressorNodeConstructor(this)}createGain(){return new gainNodeConstructor(this)}createIIRFilter(feedforward,feedback){return new iIRFilterNodeConstructor(this,{feedback,feedforward})}createOscillator(){return new oscillatorNodeConstructor(this)}createPanner(){return new pannerNodeConstructor(this)}createPeriodicWave(real,imag,constraints={disableNormalization:!1}){return new periodicWaveConstructor(this,{...constraints,imag,real})}createStereoPanner(){return new stereoPannerNodeConstructor(this)}createWaveShaper(){return new waveShaperNodeConstructor(this)}decodeAudioData(audioData,successCallback,errorCallback){return decodeAudioData(this._nativeContext,audioData).then(audioBuffer=>("function"==typeof successCallback&&successCallback(audioBuffer),audioBuffer),err=>{throw"function"==typeof errorCallback&&errorCallback(err),err})}})(addAudioWorkletModule,analyserNodeConstructor,audioBufferConstructor,audioBufferSourceNodeConstructor,biquadFilterNodeConstructor,channelMergerNodeConstructor,channelSplitterNodeConstructor,constantSourceNodeConstructor,convolverNodeConstructor,decodeAudioData,delayNodeConstructor,dynamicsCompressorNodeConstructor,gainNodeConstructor,iIRFilterNodeConstructor,minimalBaseAudioContextConstructor,oscillatorNodeConstructor,pannerNodeConstructor,periodicWaveConstructor,stereoPannerNodeConstructor,waveShaperNodeConstructor),mediaElementAudioSourceNodeConstructor=((audioNodeConstructor,createNativeMediaElementAudioSourceNode,getNativeContext,isNativeOfflineAudioContext)=>class MediaElementAudioSourceNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),nativeMediaElementAudioSourceNode=createNativeMediaElementAudioSourceNode(nativeContext,options);if(isNativeOfflineAudioContext(nativeContext))throw TypeError();super(context,!0,nativeMediaElementAudioSourceNode,null),this._nativeMediaElementAudioSourceNode=nativeMediaElementAudioSourceNode}get mediaElement(){return this._nativeMediaElementAudioSourceNode.mediaElement}})(audioNodeConstructor,(nativeAudioContext,options)=>nativeAudioContext.createMediaElementSource(options.mediaElement),getNativeContext,isNativeOfflineAudioContext),mediaStreamAudioDestinationNodeConstructor=((audioNodeConstructor,createNativeMediaStreamAudioDestinationNode,getNativeContext,isNativeOfflineAudioContext)=>class MediaStreamAudioDestinationNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context);if(isNativeOfflineAudioContext(nativeContext))throw new TypeError;const mergedOptions={...media_stream_audio_destination_node_constructor_DEFAULT_OPTIONS,...options},nativeMediaStreamAudioDestinationNode=createNativeMediaStreamAudioDestinationNode(nativeContext,mergedOptions);super(context,!1,nativeMediaStreamAudioDestinationNode,null),this._nativeMediaStreamAudioDestinationNode=nativeMediaStreamAudioDestinationNode}get stream(){return this._nativeMediaStreamAudioDestinationNode.stream}})(audioNodeConstructor,(nativeAudioContext,options)=>{const nativeMediaStreamAudioDestinationNode=nativeAudioContext.createMediaStreamDestination();return assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode,options),1===nativeMediaStreamAudioDestinationNode.numberOfOutputs&&Object.defineProperty(nativeMediaStreamAudioDestinationNode,"numberOfOutputs",{get:()=>0}),nativeMediaStreamAudioDestinationNode},getNativeContext,isNativeOfflineAudioContext),mediaStreamAudioSourceNodeConstructor=((audioNodeConstructor,createNativeMediaStreamAudioSourceNode,getNativeContext,isNativeOfflineAudioContext)=>class MediaStreamAudioSourceNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context),nativeMediaStreamAudioSourceNode=createNativeMediaStreamAudioSourceNode(nativeContext,options);if(isNativeOfflineAudioContext(nativeContext))throw new TypeError;super(context,!0,nativeMediaStreamAudioSourceNode,null),this._nativeMediaStreamAudioSourceNode=nativeMediaStreamAudioSourceNode}get mediaStream(){return this._nativeMediaStreamAudioSourceNode.mediaStream}})(audioNodeConstructor,(nativeAudioContext,{mediaStream})=>{const audioStreamTracks=mediaStream.getAudioTracks();audioStreamTracks.sort((a,b)=>a.id<b.id?-1:a.id>b.id?1:0);const filteredAudioStreamTracks=audioStreamTracks.slice(0,1),nativeMediaStreamAudioSourceNode=nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));return Object.defineProperty(nativeMediaStreamAudioSourceNode,"mediaStream",{value:mediaStream}),nativeMediaStreamAudioSourceNode},getNativeContext,isNativeOfflineAudioContext),createNativeMediaStreamTrackAudioSourceNode=((createInvalidStateError,isNativeOfflineAudioContext)=>(nativeAudioContext,{mediaStreamTrack})=>{if("function"==typeof nativeAudioContext.createMediaStreamTrackSource)return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);const mediaStream=new MediaStream([mediaStreamTrack]),nativeMediaStreamAudioSourceNode=nativeAudioContext.createMediaStreamSource(mediaStream);if("audio"!==mediaStreamTrack.kind)throw createInvalidStateError();if(isNativeOfflineAudioContext(nativeAudioContext))throw new TypeError;return nativeMediaStreamAudioSourceNode})(createInvalidStateError,isNativeOfflineAudioContext),mediaStreamTrackAudioSourceNodeConstructor=((audioNodeConstructor,createNativeMediaStreamTrackAudioSourceNode,getNativeContext)=>class MediaStreamTrackAudioSourceNode extends audioNodeConstructor{constructor(context,options){const nativeContext=getNativeContext(context);super(context,!0,createNativeMediaStreamTrackAudioSourceNode(nativeContext,options),null)}})(audioNodeConstructor,createNativeMediaStreamTrackAudioSourceNode,getNativeContext),audioContextConstructor=((baseAudioContextConstructor,createInvalidStateError,createNotSupportedError,createUnknownError,mediaElementAudioSourceNodeConstructor,mediaStreamAudioDestinationNodeConstructor,mediaStreamAudioSourceNodeConstructor,mediaStreamTrackAudioSourceNodeConstructor,nativeAudioContextConstructor)=>class AudioContext extends baseAudioContextConstructor{constructor(options={}){if(null===nativeAudioContextConstructor)throw new Error("Missing the native AudioContext constructor.");let nativeAudioContext;try{nativeAudioContext=new nativeAudioContextConstructor(options)}catch(err){if(12===err.code&&"sampleRate is not in range"===err.message)throw createNotSupportedError();throw err}if(null===nativeAudioContext)throw createUnknownError();if(!isValidLatencyHint(options.latencyHint))throw new TypeError(`The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`);if(void 0!==options.sampleRate&&nativeAudioContext.sampleRate!==options.sampleRate)throw createNotSupportedError();super(nativeAudioContext,2);const{latencyHint}=options,{sampleRate}=nativeAudioContext;if(this._baseLatency="number"==typeof nativeAudioContext.baseLatency?nativeAudioContext.baseLatency:"balanced"===latencyHint?512/sampleRate:"interactive"===latencyHint||void 0===latencyHint?256/sampleRate:"playback"===latencyHint?1024/sampleRate:128*Math.max(2,Math.min(128,Math.round(latencyHint*sampleRate/128)))/sampleRate,this._nativeAudioContext=nativeAudioContext,"webkitAudioContext"===nativeAudioContextConstructor.name?(this._nativeGainNode=nativeAudioContext.createGain(),this._nativeOscillatorNode=nativeAudioContext.createOscillator(),this._nativeGainNode.gain.value=1e-37,this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination),this._nativeOscillatorNode.start()):(this._nativeGainNode=null,this._nativeOscillatorNode=null),this._state=null,"running"===nativeAudioContext.state){this._state="suspended";const revokeState=()=>{"suspended"===this._state&&(this._state=null),nativeAudioContext.removeEventListener("statechange",revokeState)};nativeAudioContext.addEventListener("statechange",revokeState)}}get baseLatency(){return this._baseLatency}get state(){return null!==this._state?this._state:this._nativeAudioContext.state}close(){return"closed"===this.state?this._nativeAudioContext.close().then(()=>{throw createInvalidStateError()}):("suspended"===this._state&&(this._state=null),this._nativeAudioContext.close().then(()=>{null!==this._nativeGainNode&&null!==this._nativeOscillatorNode&&(this._nativeOscillatorNode.stop(),this._nativeGainNode.disconnect(),this._nativeOscillatorNode.disconnect()),deactivateAudioGraph(this)}))}createMediaElementSource(mediaElement){return new mediaElementAudioSourceNodeConstructor(this,{mediaElement})}createMediaStreamDestination(){return new mediaStreamAudioDestinationNodeConstructor(this)}createMediaStreamSource(mediaStream){return new mediaStreamAudioSourceNodeConstructor(this,{mediaStream})}createMediaStreamTrackSource(mediaStreamTrack){return new mediaStreamTrackAudioSourceNodeConstructor(this,{mediaStreamTrack})}resume(){return"suspended"===this._state?new Promise((resolve,reject)=>{const resolvePromise=()=>{this._nativeAudioContext.removeEventListener("statechange",resolvePromise),"running"===this._nativeAudioContext.state?resolve():this.resume().then(resolve,reject)};this._nativeAudioContext.addEventListener("statechange",resolvePromise)}):this._nativeAudioContext.resume().catch(err=>{if(void 0===err||15===err.code)throw createInvalidStateError();throw err})}suspend(){return this._nativeAudioContext.suspend().catch(err=>{if(void 0===err)throw createInvalidStateError();throw err})}})(baseAudioContextConstructor,createInvalidStateError,createNotSupportedError,createUnknownError,mediaElementAudioSourceNodeConstructor,mediaStreamAudioDestinationNodeConstructor,mediaStreamAudioSourceNodeConstructor,mediaStreamTrackAudioSourceNodeConstructor,nativeAudioContextConstructor),getUnrenderedAudioWorkletNodes=(unrenderedAudioWorkletNodeStore=>nativeContext=>{const unrenderedAudioWorkletNodes=unrenderedAudioWorkletNodeStore.get(nativeContext);if(void 0===unrenderedAudioWorkletNodes)throw new Error("The context has no set of AudioWorkletNodes.");return unrenderedAudioWorkletNodes})(unrenderedAudioWorkletNodeStore),addUnrenderedAudioWorkletNode=(getUnrenderedAudioWorkletNodes=>(nativeContext,audioWorkletNode)=>{getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode)})(getUnrenderedAudioWorkletNodes),connectMultipleOutputs=(createIndexSizeError=>(outputAudioNodes,destination,output=0,input=0)=>{const outputAudioNode=outputAudioNodes[output];if(void 0===outputAudioNode)throw createIndexSizeError();return isNativeAudioNode(destination)?outputAudioNode.connect(destination,0,input):outputAudioNode.connect(destination,0)})(createIndexSizeError),deleteUnrenderedAudioWorkletNode=(getUnrenderedAudioWorkletNodes=>(nativeContext,audioWorkletNode)=>{getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode)})(getUnrenderedAudioWorkletNodes),disconnectMultipleOutputs=(createIndexSizeError=>(outputAudioNodes,destinationOrOutput=void 0,output=void 0,input=0)=>void 0===destinationOrOutput?outputAudioNodes.forEach(outputAudioNode=>outputAudioNode.disconnect()):"number"==typeof destinationOrOutput?getOutputAudioNodeAtIndex(createIndexSizeError,outputAudioNodes,destinationOrOutput).disconnect():isNativeAudioNode(destinationOrOutput)?void 0===output?outputAudioNodes.forEach(outputAudioNode=>outputAudioNode.disconnect(destinationOrOutput)):void 0===input?getOutputAudioNodeAtIndex(createIndexSizeError,outputAudioNodes,output).disconnect(destinationOrOutput,0):getOutputAudioNodeAtIndex(createIndexSizeError,outputAudioNodes,output).disconnect(destinationOrOutput,0,input):void 0===output?outputAudioNodes.forEach(outputAudioNode=>outputAudioNode.disconnect(destinationOrOutput)):getOutputAudioNodeAtIndex(createIndexSizeError,outputAudioNodes,output).disconnect(destinationOrOutput,0))(createIndexSizeError),activeAudioWorkletNodeInputsStore=new WeakMap,getActiveAudioWorkletNodeInputs=((activeAudioWorkletNodeInputsStore,getValueForKey)=>nativeAudioWorkletNode=>getValueForKey(activeAudioWorkletNodeInputsStore,nativeAudioWorkletNode))(activeAudioWorkletNodeInputsStore,getValueForKey),createNativeAudioWorkletNodeFaker=((connectMultipleOutputs,createIndexSizeError,createInvalidStateError,createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeConstantSourceNode,createNativeGainNode,createNativeScriptProcessorNode,createNotSupportedError,disconnectMultipleOutputs,exposeCurrentFrameAndCurrentTime,getActiveAudioWorkletNodeInputs,monitorConnections)=>(nativeContext,baseLatency,processorConstructor,options)=>{if(0===options.numberOfInputs&&0===options.numberOfOutputs)throw createNotSupportedError();const outputChannelCount=Array.isArray(options.outputChannelCount)?options.outputChannelCount:Array.from(options.outputChannelCount);if(outputChannelCount.some(channelCount=>channelCount<1))throw createNotSupportedError();if(outputChannelCount.length!==options.numberOfOutputs)throw createIndexSizeError();if("explicit"!==options.channelCountMode)throw createNotSupportedError();const numberOfInputChannels=options.channelCount*options.numberOfInputs,numberOfOutputChannels=outputChannelCount.reduce((sum,value)=>sum+value,0),numberOfParameters=void 0===processorConstructor.parameterDescriptors?0:processorConstructor.parameterDescriptors.length;if(numberOfInputChannels+numberOfParameters>6||numberOfOutputChannels>6)throw createNotSupportedError();const messageChannel=new MessageChannel,gainNodes=[],inputChannelSplitterNodes=[];for(let i=0;i<options.numberOfInputs;i+=1)gainNodes.push(createNativeGainNode(nativeContext,{channelCount:options.channelCount,channelCountMode:options.channelCountMode,channelInterpretation:options.channelInterpretation,gain:1})),inputChannelSplitterNodes.push(createNativeChannelSplitterNode(nativeContext,{channelCount:options.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:options.channelCount}));const constantSourceNodes=[];if(void 0!==processorConstructor.parameterDescriptors)for(const{defaultValue,maxValue,minValue,name}of processorConstructor.parameterDescriptors){const constantSourceNode=createNativeConstantSourceNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:void 0!==options.parameterData[name]?options.parameterData[name]:void 0===defaultValue?0:defaultValue});Object.defineProperties(constantSourceNode.offset,{defaultValue:{get:()=>void 0===defaultValue?0:defaultValue},maxValue:{get:()=>void 0===maxValue?MOST_POSITIVE_SINGLE_FLOAT:maxValue},minValue:{get:()=>void 0===minValue?MOST_NEGATIVE_SINGLE_FLOAT:minValue}}),constantSourceNodes.push(constantSourceNode)}const inputChannelMergerNode=createNativeChannelMergerNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,numberOfInputChannels+numberOfParameters)}),bufferSize=computeBufferSize(baseLatency,nativeContext.sampleRate),scriptProcessorNode=createNativeScriptProcessorNode(nativeContext,bufferSize,numberOfInputChannels+numberOfParameters,Math.max(1,numberOfOutputChannels)),outputChannelSplitterNode=createNativeChannelSplitterNode(nativeContext,{channelCount:Math.max(1,numberOfOutputChannels),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,numberOfOutputChannels)}),outputChannelMergerNodes=[];for(let i=0;i<options.numberOfOutputs;i+=1)outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:outputChannelCount[i]}));for(let i=0;i<options.numberOfInputs;i+=1){gainNodes[i].connect(inputChannelSplitterNodes[i]);for(let j=0;j<options.channelCount;j+=1)inputChannelSplitterNodes[i].connect(inputChannelMergerNode,j,i*options.channelCount+j)}const parameterMap=new ReadOnlyMap(void 0===processorConstructor.parameterDescriptors?[]:processorConstructor.parameterDescriptors.map(({name},index)=>{const constantSourceNode=constantSourceNodes[index];return constantSourceNode.connect(inputChannelMergerNode,0,numberOfInputChannels+index),constantSourceNode.start(0),[name,constantSourceNode.offset]}));inputChannelMergerNode.connect(scriptProcessorNode);let channelInterpretation=options.channelInterpretation,onprocessorerror=null;const outputAudioNodes=0===options.numberOfOutputs?[scriptProcessorNode]:outputChannelMergerNodes,nativeAudioWorkletNodeFaker={get bufferSize(){return bufferSize},get channelCount(){return options.channelCount},set channelCount(_){throw createInvalidStateError()},get channelCountMode(){return options.channelCountMode},set channelCountMode(_){throw createInvalidStateError()},get channelInterpretation(){return channelInterpretation},set channelInterpretation(value){for(const gainNode of gainNodes)gainNode.channelInterpretation=value;channelInterpretation=value},get context(){return scriptProcessorNode.context},get inputs(){return gainNodes},get numberOfInputs(){return options.numberOfInputs},get numberOfOutputs(){return options.numberOfOutputs},get onprocessorerror(){return onprocessorerror},set onprocessorerror(value){"function"==typeof onprocessorerror&&nativeAudioWorkletNodeFaker.removeEventListener("processorerror",onprocessorerror),onprocessorerror="function"==typeof value?value:null,"function"==typeof onprocessorerror&&nativeAudioWorkletNodeFaker.addEventListener("processorerror",onprocessorerror)},get parameters(){return parameterMap},get port(){return messageChannel.port2},addEventListener:(...args)=>scriptProcessorNode.addEventListener(args[0],args[1],args[2]),connect:connectMultipleOutputs.bind(null,outputAudioNodes),disconnect:disconnectMultipleOutputs.bind(null,outputAudioNodes),dispatchEvent:(...args)=>scriptProcessorNode.dispatchEvent(args[0]),removeEventListener:(...args)=>scriptProcessorNode.removeEventListener(args[0],args[1],args[2])},patchedEventListeners=new Map;var addEventListener,removeEventListener;messageChannel.port1.addEventListener=(addEventListener=messageChannel.port1.addEventListener,(...args)=>{if("message"===args[0]){const unpatchedEventListener="function"==typeof args[1]?args[1]:"object"==typeof args[1]&&null!==args[1]&&"function"==typeof args[1].handleEvent?args[1].handleEvent:null;if(null!==unpatchedEventListener){const patchedEventListener=patchedEventListeners.get(args[1]);void 0!==patchedEventListener?args[1]=patchedEventListener:(args[1]=event=>{exposeCurrentFrameAndCurrentTime(nativeContext.currentTime,nativeContext.sampleRate,()=>unpatchedEventListener(event))},patchedEventListeners.set(unpatchedEventListener,args[1]))}}return addEventListener.call(messageChannel.port1,args[0],args[1],args[2])}),messageChannel.port1.removeEventListener=(removeEventListener=messageChannel.port1.removeEventListener,(...args)=>{if("message"===args[0]){const patchedEventListener=patchedEventListeners.get(args[1]);void 0!==patchedEventListener&&(patchedEventListeners.delete(args[1]),args[1]=patchedEventListener)}return removeEventListener.call(messageChannel.port1,args[0],args[1],args[2])});let onmessage=null;Object.defineProperty(messageChannel.port1,"onmessage",{get:()=>onmessage,set:value=>{"function"==typeof onmessage&&messageChannel.port1.removeEventListener("message",onmessage),onmessage="function"==typeof value?value:null,"function"==typeof onmessage&&(messageChannel.port1.addEventListener("message",onmessage),messageChannel.port1.start())}}),processorConstructor.prototype.port=messageChannel.port1;let audioWorkletProcessor=null;const audioWorkletProcessorPromise=((nativeContext,nativeAudioWorkletNode,processorConstructor,audioWorkletNodeOptions)=>{let nodeToProcessorMap=NODE_TO_PROCESSOR_MAPS.get(nativeContext);void 0===nodeToProcessorMap&&(nodeToProcessorMap=new WeakMap,NODE_TO_PROCESSOR_MAPS.set(nativeContext,nodeToProcessorMap));const audioWorkletProcessorPromise=createAudioWorkletProcessorPromise(processorConstructor,audioWorkletNodeOptions);return nodeToProcessorMap.set(nativeAudioWorkletNode,audioWorkletProcessorPromise),audioWorkletProcessorPromise})(nativeContext,nativeAudioWorkletNodeFaker,processorConstructor,options);audioWorkletProcessorPromise.then(dWrkltPrcssr=>audioWorkletProcessor=dWrkltPrcssr);const inputs=createNestedArrays(options.numberOfInputs,options.channelCount),outputs=createNestedArrays(options.numberOfOutputs,outputChannelCount),parameters=void 0===processorConstructor.parameterDescriptors?[]:processorConstructor.parameterDescriptors.reduce((prmtrs,{name})=>({...prmtrs,[name]:new Float32Array(128)}),{});let isActive=!0;const disconnectOutputsGraph=()=>{options.numberOfOutputs>0&&scriptProcessorNode.disconnect(outputChannelSplitterNode);for(let i=0,outputChannelSplitterNodeOutput=0;i<options.numberOfOutputs;i+=1){const outputChannelMergerNode=outputChannelMergerNodes[i];for(let j=0;j<outputChannelCount[i];j+=1)outputChannelSplitterNode.disconnect(outputChannelMergerNode,outputChannelSplitterNodeOutput+j,j);outputChannelSplitterNodeOutput+=outputChannelCount[i]}},activeInputIndexes=new Map;scriptProcessorNode.onaudioprocess=({inputBuffer,outputBuffer})=>{if(null!==audioWorkletProcessor){const activeInputs=getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);for(let i=0;i<bufferSize;i+=128){for(let j=0;j<options.numberOfInputs;j+=1)for(let k=0;k<options.channelCount;k+=1)copyFromChannel(inputBuffer,inputs[j],k,k,i);void 0!==processorConstructor.parameterDescriptors&&processorConstructor.parameterDescriptors.forEach(({name},index)=>{copyFromChannel(inputBuffer,parameters,name,numberOfInputChannels+index,i)});for(let j=0;j<options.numberOfInputs;j+=1)for(let k=0;k<outputChannelCount[j];k+=1)0===outputs[j][k].byteLength&&(outputs[j][k]=new Float32Array(128));try{const potentiallyEmptyInputs=inputs.map((input,index)=>{if(activeInputs[index].size>0)return activeInputIndexes.set(index,bufferSize/128),input;const count=activeInputIndexes.get(index);return void 0===count?[]:(input.every(channelData=>channelData.every(sample=>0===sample))&&(1===count?activeInputIndexes.delete(index):activeInputIndexes.set(index,count-1)),input)}),activeSourceFlag=exposeCurrentFrameAndCurrentTime(nativeContext.currentTime+i/nativeContext.sampleRate,nativeContext.sampleRate,()=>audioWorkletProcessor.process(potentiallyEmptyInputs,outputs,parameters));isActive=activeSourceFlag;for(let j=0,outputChannelSplitterNodeOutput=0;j<options.numberOfOutputs;j+=1){for(let k=0;k<outputChannelCount[j];k+=1)copyToChannel(outputBuffer,outputs[j],k,outputChannelSplitterNodeOutput+k,i);outputChannelSplitterNodeOutput+=outputChannelCount[j]}}catch(error){isActive=!1,nativeAudioWorkletNodeFaker.dispatchEvent(new ErrorEvent("processorerror",{colno:error.colno,filename:error.filename,lineno:error.lineno,message:error.message}))}if(!isActive){for(let j=0;j<options.numberOfInputs;j+=1){gainNodes[j].disconnect(inputChannelSplitterNodes[j]);for(let k=0;k<options.channelCount;k+=1)inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode,k,j*options.channelCount+k)}if(void 0!==processorConstructor.parameterDescriptors){const length=processorConstructor.parameterDescriptors.length;for(let j=0;j<length;j+=1){const constantSourceNode=constantSourceNodes[j];constantSourceNode.disconnect(inputChannelMergerNode,0,numberOfInputChannels+j),constantSourceNode.stop()}}inputChannelMergerNode.disconnect(scriptProcessorNode),scriptProcessorNode.onaudioprocess=null,isConnected?disconnectOutputsGraph():disconnectFakeGraph();break}}}};let isConnected=!1;const nativeGainNode=createNativeGainNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0}),connectFakeGraph=()=>scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination),disconnectFakeGraph=()=>{scriptProcessorNode.disconnect(nativeGainNode),nativeGainNode.disconnect()};return connectFakeGraph(),monitorConnections(nativeAudioWorkletNodeFaker,()=>{if(isActive){disconnectFakeGraph(),options.numberOfOutputs>0&&scriptProcessorNode.connect(outputChannelSplitterNode);for(let i=0,outputChannelSplitterNodeOutput=0;i<options.numberOfOutputs;i+=1){const outputChannelMergerNode=outputChannelMergerNodes[i];for(let j=0;j<outputChannelCount[i];j+=1)outputChannelSplitterNode.connect(outputChannelMergerNode,outputChannelSplitterNodeOutput+j,j);outputChannelSplitterNodeOutput+=outputChannelCount[i]}}isConnected=!0},()=>{isActive&&(connectFakeGraph(),disconnectOutputsGraph()),isConnected=!1})})(connectMultipleOutputs,createIndexSizeError,createInvalidStateError,createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeConstantSourceNode,createNativeGainNode,createNativeScriptProcessorNode,createNotSupportedError,disconnectMultipleOutputs,exposeCurrentFrameAndCurrentTime,getActiveAudioWorkletNodeInputs,monitorConnections),createNativeAudioWorkletNode=((createInvalidStateError,createNativeAudioWorkletNodeFaker,createNativeGainNode,createNotSupportedError,monitorConnections)=>(nativeContext,baseLatency,nativeAudioWorkletNodeConstructor,name,processorConstructor,options)=>{if(null!==nativeAudioWorkletNodeConstructor)try{const nativeAudioWorkletNode=new nativeAudioWorkletNodeConstructor(nativeContext,name,options),patchedEventListeners=new Map;let onprocessorerror=null;if(Object.defineProperties(nativeAudioWorkletNode,{channelCount:{get:()=>options.channelCount,set:()=>{throw createInvalidStateError()}},channelCountMode:{get:()=>"explicit",set:()=>{throw createInvalidStateError()}},onprocessorerror:{get:()=>onprocessorerror,set:value=>{"function"==typeof onprocessorerror&&nativeAudioWorkletNode.removeEventListener("processorerror",onprocessorerror),onprocessorerror="function"==typeof value?value:null,"function"==typeof onprocessorerror&&nativeAudioWorkletNode.addEventListener("processorerror",onprocessorerror)}}}),nativeAudioWorkletNode.addEventListener=(addEventListener=nativeAudioWorkletNode.addEventListener,(...args)=>{if("processorerror"===args[0]){const unpatchedEventListener="function"==typeof args[1]?args[1]:"object"==typeof args[1]&&null!==args[1]&&"function"==typeof args[1].handleEvent?args[1].handleEvent:null;if(null!==unpatchedEventListener){const patchedEventListener=patchedEventListeners.get(args[1]);void 0!==patchedEventListener?args[1]=patchedEventListener:(args[1]=event=>{"error"===event.type?(Object.defineProperties(event,{type:{value:"processorerror"}}),unpatchedEventListener(event)):unpatchedEventListener(new ErrorEvent(args[0],{...event}))},patchedEventListeners.set(unpatchedEventListener,args[1]))}}return addEventListener.call(nativeAudioWorkletNode,"error",args[1],args[2]),addEventListener.call(nativeAudioWorkletNode,...args)}),nativeAudioWorkletNode.removeEventListener=(removeEventListener=nativeAudioWorkletNode.removeEventListener,(...args)=>{if("processorerror"===args[0]){const patchedEventListener=patchedEventListeners.get(args[1]);void 0!==patchedEventListener&&(patchedEventListeners.delete(args[1]),args[1]=patchedEventListener)}return removeEventListener.call(nativeAudioWorkletNode,"error",args[1],args[2]),removeEventListener.call(nativeAudioWorkletNode,args[0],args[1],args[2])}),0!==options.numberOfOutputs){const nativeGainNode=createNativeGainNode(nativeContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",gain:0});nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);return monitorConnections(nativeAudioWorkletNode,()=>nativeGainNode.disconnect(),()=>nativeGainNode.connect(nativeContext.destination))}return nativeAudioWorkletNode}catch(err){if(11===err.code)throw createNotSupportedError();throw err}var removeEventListener,addEventListener;if(void 0===processorConstructor)throw createNotSupportedError();return(audioWorkletNodeOptions=>{const{port1}=new MessageChannel;try{port1.postMessage(audioWorkletNodeOptions)}finally{port1.close()}})(options),createNativeAudioWorkletNodeFaker(nativeContext,baseLatency,processorConstructor,options)})(createInvalidStateError,createNativeAudioWorkletNodeFaker,createNativeGainNode,createNotSupportedError,monitorConnections),createAudioWorkletNodeRenderer=((connectAudioParam,connectMultipleOutputs,createNativeAudioBufferSourceNode,createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeConstantSourceNode,createNativeGainNode,deleteUnrenderedAudioWorkletNode,disconnectMultipleOutputs,exposeCurrentFrameAndCurrentTime,getNativeAudioNode,nativeAudioWorkletNodeConstructor,nativeOfflineAudioContextConstructor,renderAutomation,renderInputsOfAudioNode,renderNativeOfflineAudioContext)=>(name,options,processorConstructor)=>{const renderedNativeAudioNodes=new WeakMap;let processedBufferPromise=null;return{render(proxy,nativeOfflineAudioContext){deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext,proxy);const renderedNativeAudioWorkletNodeOrGainNode=renderedNativeAudioNodes.get(nativeOfflineAudioContext);return void 0!==renderedNativeAudioWorkletNodeOrGainNode?Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode):(async(proxy,nativeOfflineAudioContext)=>{let nativeAudioWorkletNode=getNativeAudioNode(proxy),nativeOutputNodes=null;const nativeAudioWorkletNodeIsOwnedByContext=isOwnedByContext(nativeAudioWorkletNode,nativeOfflineAudioContext),outputChannelCount=Array.isArray(options.outputChannelCount)?options.outputChannelCount:Array.from(options.outputChannelCount);if(null===nativeAudioWorkletNodeConstructor){const numberOfOutputChannels=outputChannelCount.reduce((sum,value)=>sum+value,0),outputChannelSplitterNode=createNativeChannelSplitterNode(nativeOfflineAudioContext,{channelCount:Math.max(1,numberOfOutputChannels),channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:Math.max(1,numberOfOutputChannels)}),outputChannelMergerNodes=[];for(let i=0;i<proxy.numberOfOutputs;i+=1)outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:outputChannelCount[i]}));const outputGainNode=createNativeGainNode(nativeOfflineAudioContext,{channelCount:options.channelCount,channelCountMode:options.channelCountMode,channelInterpretation:options.channelInterpretation,gain:1});outputGainNode.connect=connectMultipleOutputs.bind(null,outputChannelMergerNodes),outputGainNode.disconnect=disconnectMultipleOutputs.bind(null,outputChannelMergerNodes),nativeOutputNodes=[outputChannelSplitterNode,outputChannelMergerNodes,outputGainNode]}else nativeAudioWorkletNodeIsOwnedByContext||(nativeAudioWorkletNode=new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext,name));if(renderedNativeAudioNodes.set(nativeOfflineAudioContext,null===nativeOutputNodes?nativeAudioWorkletNode:nativeOutputNodes[2]),null!==nativeOutputNodes){if(null===processedBufferPromise){if(void 0===processorConstructor)throw new Error("Missing the processor constructor.");if(null===nativeOfflineAudioContextConstructor)throw new Error("Missing the native OfflineAudioContext constructor.");const numberOfInputChannels=proxy.channelCount*proxy.numberOfInputs,numberOfParameters=void 0===processorConstructor.parameterDescriptors?0:processorConstructor.parameterDescriptors.length,numberOfChannels=numberOfInputChannels+numberOfParameters,renderBuffer=async()=>{const partialOfflineAudioContext=new nativeOfflineAudioContextConstructor(numberOfChannels,128*Math.ceil(proxy.context.length/128),nativeOfflineAudioContext.sampleRate),gainNodes=[],inputChannelSplitterNodes=[];for(let i=0;i<options.numberOfInputs;i+=1)gainNodes.push(createNativeGainNode(partialOfflineAudioContext,{channelCount:options.channelCount,channelCountMode:options.channelCountMode,channelInterpretation:options.channelInterpretation,gain:1})),inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext,{channelCount:options.channelCount,channelCountMode:"explicit",channelInterpretation:"discrete",numberOfOutputs:options.channelCount}));const constantSourceNodes=await Promise.all(Array.from(proxy.parameters.values()).map(async audioParam=>{const constantSourceNode=createNativeConstantSourceNode(partialOfflineAudioContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"discrete",offset:audioParam.value});return await renderAutomation(partialOfflineAudioContext,audioParam,constantSourceNode.offset),constantSourceNode})),inputChannelMergerNode=createNativeChannelMergerNode(partialOfflineAudioContext,{channelCount:1,channelCountMode:"explicit",channelInterpretation:"speakers",numberOfInputs:Math.max(1,numberOfInputChannels+numberOfParameters)});for(let i=0;i<options.numberOfInputs;i+=1){gainNodes[i].connect(inputChannelSplitterNodes[i]);for(let j=0;j<options.channelCount;j+=1)inputChannelSplitterNodes[i].connect(inputChannelMergerNode,j,i*options.channelCount+j)}for(const[index,constantSourceNode]of constantSourceNodes.entries())constantSourceNode.connect(inputChannelMergerNode,0,numberOfInputChannels+index),constantSourceNode.start(0);return inputChannelMergerNode.connect(partialOfflineAudioContext.destination),await Promise.all(gainNodes.map(gainNode=>renderInputsOfAudioNode(proxy,partialOfflineAudioContext,gainNode))),renderNativeOfflineAudioContext(partialOfflineAudioContext)};processedBufferPromise=processBuffer(proxy,0===numberOfChannels?null:await renderBuffer(),nativeOfflineAudioContext,options,outputChannelCount,processorConstructor,exposeCurrentFrameAndCurrentTime)}const processedBuffer=await processedBufferPromise,audioBufferSourceNode=createNativeAudioBufferSourceNode(nativeOfflineAudioContext,{buffer:null,channelCount:2,channelCountMode:"max",channelInterpretation:"speakers",loop:!1,loopEnd:0,loopStart:0,playbackRate:1}),[outputChannelSplitterNode,outputChannelMergerNodes,outputGainNode]=nativeOutputNodes;null!==processedBuffer&&(audioBufferSourceNode.buffer=processedBuffer,audioBufferSourceNode.start(0)),audioBufferSourceNode.connect(outputChannelSplitterNode);for(let i=0,outputChannelSplitterNodeOutput=0;i<proxy.numberOfOutputs;i+=1){const outputChannelMergerNode=outputChannelMergerNodes[i];for(let j=0;j<outputChannelCount[i];j+=1)outputChannelSplitterNode.connect(outputChannelMergerNode,outputChannelSplitterNodeOutput+j,j);outputChannelSplitterNodeOutput+=outputChannelCount[i]}return outputGainNode}if(nativeAudioWorkletNodeIsOwnedByContext)for(const[nm,audioParam]of proxy.parameters.entries())await connectAudioParam(nativeOfflineAudioContext,audioParam,nativeAudioWorkletNode.parameters.get(nm));else for(const[nm,audioParam]of proxy.parameters.entries())await renderAutomation(nativeOfflineAudioContext,audioParam,nativeAudioWorkletNode.parameters.get(nm));return await renderInputsOfAudioNode(proxy,nativeOfflineAudioContext,nativeAudioWorkletNode),nativeAudioWorkletNode})(proxy,nativeOfflineAudioContext)}}})(connectAudioParam,connectMultipleOutputs,createNativeAudioBufferSourceNode,createNativeChannelMergerNode,createNativeChannelSplitterNode,createNativeConstantSourceNode,createNativeGainNode,deleteUnrenderedAudioWorkletNode,disconnectMultipleOutputs,exposeCurrentFrameAndCurrentTime,getNativeAudioNode,nativeAudioWorkletNodeConstructor,nativeOfflineAudioContextConstructor,renderAutomation,renderInputsOfAudioNode,renderNativeOfflineAudioContext),getBackupOfflineAudioContext=(backupOfflineAudioContextStore=>nativeContext=>backupOfflineAudioContextStore.get(nativeContext))(backupOfflineAudioContextStore),setActiveAudioWorkletNodeInputs=(activeAudioWorkletNodeInputsStore=>(nativeAudioWorkletNode,activeInputs)=>{activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode,activeInputs)})(activeAudioWorkletNodeInputsStore),createNativeOfflineAudioContext=(isSecureContext&&((addUnrenderedAudioWorkletNode,audioNodeConstructor,createAudioParam,createAudioWorkletNodeRenderer,createNativeAudioWorkletNode,getAudioNodeConnections,getBackupOfflineAudioContext,getNativeContext,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor,sanitizeAudioWorkletNodeOptions,setActiveAudioWorkletNodeInputs,testAudioWorkletNodeOptionsClonability,wrapEventListener)=>{})(addUnrenderedAudioWorkletNode,audioNodeConstructor,createAudioParam,createAudioWorkletNodeRenderer,createNativeAudioWorkletNode,getAudioNodeConnections,getBackupOfflineAudioContext,getNativeContext,isNativeOfflineAudioContext,nativeAudioWorkletNodeConstructor,options=>({...options,outputChannelCount:void 0!==options.outputChannelCount?options.outputChannelCount:1===options.numberOfInputs&&1===options.numberOfOutputs?[options.channelCount]:Array.from({length:options.numberOfOutputs},()=>1)}),setActiveAudioWorkletNodeInputs,audioWorkletNodeOptions=>{const{port1,port2}=new MessageChannel;try{port1.postMessage(audioWorkletNodeOptions)}finally{port1.close(),port2.close()}},wrapEventListener),((createInvalidStateError,createNotSupportedError,createUnknownError,minimalBaseAudioContextConstructor,nativeAudioContextConstructor)=>{})(createInvalidStateError,createNotSupportedError,createUnknownError,minimalBaseAudioContextConstructor,nativeAudioContextConstructor),((createNotSupportedError,nativeOfflineAudioContextConstructor)=>(numberOfChannels,length,sampleRate)=>{if(null===nativeOfflineAudioContextConstructor)throw new Error("Missing the native OfflineAudioContext constructor.");try{return new nativeOfflineAudioContextConstructor(numberOfChannels,length,sampleRate)}catch(err){if("SyntaxError"===err.name)throw createNotSupportedError();throw err}})(createNotSupportedError,nativeOfflineAudioContextConstructor)),startRendering=((audioBufferStore,cacheTestResult,getAudioNodeRenderer,getUnrenderedAudioWorkletNodes,renderNativeOfflineAudioContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds)=>(destination,nativeOfflineAudioContext)=>getAudioNodeRenderer(destination).render(destination,nativeOfflineAudioContext).then(()=>Promise.all(Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map(audioWorkletNode=>getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode,nativeOfflineAudioContext)))).then(()=>renderNativeOfflineAudioContext(nativeOfflineAudioContext)).then(audioBuffer=>("function"!=typeof audioBuffer.copyFromChannel?(wrapAudioBufferCopyChannelMethods(audioBuffer),wrapAudioBufferGetChannelDataMethod(audioBuffer)):cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport,()=>testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer))||wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer),audioBufferStore.add(audioBuffer),audioBuffer)))(audioBufferStore,cacheTestResult,getAudioNodeRenderer,getUnrenderedAudioWorkletNodes,renderNativeOfflineAudioContext,testAudioBufferCopyChannelMethodsOutOfBoundsSupport,wrapAudioBufferCopyChannelMethods,wrapAudioBufferCopyChannelMethodsOutOfBounds)}}]);